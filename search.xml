<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库安全性笔记]]></title>
    <url>%2F2019%2F11%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库安全性概述数据库的安全性是指保护数据库以防止不合法使用造成的数据泄露、更改或破坏。 不安全因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据泄露 安全环境的脆弱性 安全标准 TCSEC（桔皮书） TCSEC/TDI（紫皮书） 从四个方面描述安全性级别划分的指标 安全策略 责任 保证 文档 级别划分 安全级别 定义 CC评级（EAL） A1 验证设计 EAL7 B3 安全域 EAL6 B2 结构化保护 EAL5 B1 标记安全保护 EAL4 C2 受控的存取保护 EAL3 C1 自主安全保护 EAL2 D 最小保护 数据库安全性控制用户身份鉴别 静态口令鉴别 动态口令鉴别 生物特征鉴别 智能卡鉴别 存取控制存取控制机制主要包括定义用户权限和合法权限检查两部分 自主存取控制方法SQL通过GRANT分配权限和REVOKE收回权限 用户权限由]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下mongoDB 错误1053 服务无法启动]]></title>
    <url>%2F2019%2F10%2F29%2Fwindows%E4%B8%8BmongoDB-%E9%94%99%E8%AF%AF1053-%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[windows 安装完mongodb并配置好后启动服务时报错： 显示这个错误 在服务窗口中查看 复制所选的命令，在powersell(管理员)中执行 查看结果 12PS C:\WINDOWS\system32&gt; E:\mongdb\bin\mongod.exe --config "E:\mongdb\bin\mongod.cfg" --serviceUnrecognized option: snmp 我显示无效的参数snmp 查看配置文件，显示： 下面多了一行snmp: 删除后再执行显示正常了就]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>mongoDB 踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2019%2F09%2F19%2F2019-09-19-jQuery%2F</url>
    <content type="text"><![CDATA[语法结构工厂函数$() 选择器Id选择器$(“#Name) 返回DOM中ID名为Name的元素 标签选择器$(“p”) 返回DOM中所有的p元素 类选择器$(“.className”) 返回DOM中class类名为className的元素 事件处理方法可以绑定 鼠标事件（click）、键盘事件（mouseover）、和 表单事件(onblur)等 示例当点击导航项时，ID为 current 的导航项添加 class为 current的样式。 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt; &lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; li&#123; list-style: none; line-height: 24px; cursor: pointer; &#125; .current&#123; background-color: red; font-weight: blod; color: #fff; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("li").click(function()&#123; $("#current").addClass("current") &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; &lt;ul&gt; &lt;li id="current"&gt;方法&lt;/li&gt; &lt;li&gt;语法&lt;/li&gt; &lt;li&gt;对象&lt;/li&gt; &lt;li&gt;事件&lt;/li&gt; &lt;/ul&gt;&lt;/html&gt; addClassaddClass() 是JQuery中用于进行CSS操作的方法之一，作用的为每个匹配的元素添加指定的样式类名。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>网页</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字电子技术基础笔记1]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[数值转换太简单了，不写了 常见编码 编码种类十进制数 8421码（BCD代码） 余3码 2421码 5211码 0 0000 0011 0000 0000 1 0001 0100 0001 0001 2 0010 0101 0010 0100 3 0011 0110 0011 0101 4 0100 0111 0100 0111 5 0101 1000 1011 1000 6 0110 1001 1100 1001 7 0111 1010 1101 1100 8 1000 1011 1110 1101 9 1001 1100 1111 1111 84218421又称BCD码，是最常用的一种表示，每一位对应的权值就是8421，每一位的权是固定不变的，属于恒权码。 余3码每一位在BCD代码的基础上加上 011（即3）得到的就是余3码。 余3码的0和9，1和9，2和8……互为反码。 余3码不是恒权码，因为如果试图将每个代码看作二进制数，并使它等效的十进制数与所表示的代码相等，那么代码中每一位的1所代表的十进制数在各个代码中是不固定的。 2421码同余3码一样，0和9，1和9，2和8……互为反码。 当2421是恒权码。 5211码5211是另一种恒权码，（在第六章学习，待补充……） 格雷码 十进制数 二进制码 格雷码 0 0000 0000 1 0001 0001 2 0010 0011 3 0011 0010 4 0100 0110 5 0101 0111 6 0110 0101 7 0111 0100 8 1000 1100 9 1001 1101 10 1010 1111 11 1011 1110 12 1100 1010 13 1101 1011 14 1110 1001 15 1111 1000 格雷码的相邻两个代码之间变化时，只有一位发生变化。 g1g0g3g2 00 01 10 11 00 0 1 2 3 01 7 6 5 4 10 8 9 10 11 11 15 14 13 12 逻辑代数中的三种基本运算与真值表 A B Y 0 0 0 1 0 0 0 1 0 1 1 1 符号表示逻辑代数中与以 “·”表示 图形表示 或真值表 A B Y 0 0 1 1 0 1 0 1 1 1 1 0 符号表示逻辑代数中与以 “+”表示 图形表示 非真值表 A Y 0 1 1 0 符号表示逻辑代数中与以 “$\overline{A}$”表示 图形表示]]></content>
      <categories>
        <category>数字电子技术基础笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数字电子技术基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建云盘cloudreve]]></title>
    <url>%2F2019%2F08%2F27%2F%E9%83%A8%E7%BD%B2cloudreve%2F</url>
    <content type="text"><![CDATA[想搭建一个云盘，虽然我也不知道为什么，之前搭建过一个nextcloud，很不错，除了速度（因为阿里云ECS学生套餐下行带宽只有2M），忽然发现cloudreve可以直接连接阿里云的oss，就想试试。 介绍 快速对接多家云存储，支持七牛、又拍云、阿里云OSS、AWS S3、Onedrive、自建远程服务器，当然，还有本地存储 可限制单文件最大大小、MIMEType、文件后缀、用户可用容量 自定义主题配色 基于Aria2的离线下载 图片、音频、视频、文本、Markdown、Ofiice文档 在线预览 移动端全站响应式布局 文件、目录分享系统，可创建私有分享或公开分享链接 用户个人主页，可查看用户所有分享 多用户系统、用户组支持 初步完善的后台，方便管理 拖拽上传、分片上传、断点续传、下载限速（*实验性功能） 多上传策略，可为不同用户组分配不同策略 用户组基础权限设置、二步验证 WebDAV协议支持 安装需求 LNMP/AMP With PHP5.6+ curl、fileinfo、gd扩展 Composer 下载与安装因为Cloudreve使用Composer实现快捷的安装与配置，解压就可以用，所以我也不想麻烦了 官网 可以直接下载zip文件，解压成文件夹就可以了（github） 配置添加站点因为使用宝塔面板，所以配置十分简单 点击网站，添加站点 设置域名，根目录设置成刚才解压的文件夹就行了 访问http://你的域名/CloudreveInstaller/ 进入配置界面 配置伪静态如果提示 2 URL Rewrite 对于Nginx,需要配置一下伪静态 123456location / &#123; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125;&#125; 设置读写权限 chomod a+w dirname 扩展 如果少扩展去宝塔里面安装就行 最后两项不用管 数据库在宝塔中创建一个数据库，这里直接写下刚才创建的各种信息就行 登录完成后会出现这个页面，你的管理界面和账户密码（进入管理员账户可以修改） OSS上传策略进入管理界面, 点击添加 然后添加信息 踩坑记录空间域名虽然他给的是http(s)://但是你要不也http:// 要不写https://，你如果直接写http(s)://域名，他会直接访问http(s)://域名，很明显，是没有http(s)协议的，所以oss的上传不会成功 OSS 配置需要在你的bucket的基础设置的跨域设置中创建规则 规则如下 应用上传策略可以在用户组中设置用户组的上传策略]]></content>
      <categories>
        <category>捣鼓记录</category>
      </categories>
      <tags>
        <tag>cloudreve</tag>
        <tag>搭建记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构-笔记7-二叉搜索树]]></title>
    <url>%2F2019%2F08%2F19%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B07%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[搜索树定义搜索树是一种可以进行插入、搜素、删除等操作的数据结构，可以用作字典或优先级队列。二叉搜索树属于最基本的搜索树。 性质设x为二叉搜索树的结点，如果y是x左子树的结点，那么y的键值小于等于x的键值。如果z是x的右子树中的结点，那么x的键值小于等于z的键值。 如图所示 当数据进行插入或者删除操作后，所有结点仍然满足上述的性质。 插入伪代码insert方法用于在二叉搜索树T中插入新值v，insert 将键值为v，左子树为NIL，右子树为NIL的点z作为实参传入 1234567891011121314151617insert(T,z) y=NIL //x的父结点 x='T的根节点' while x!=NIL y=x //设置父结点 if z.key &lt; x.key x=x.left else x=x.right z.p=y if y==NIL //T为空时 'T的根节点'=z else if z.key &lt;y.key y.left=z //将z定为y的左子结点 else y.right=z //将z定为y的右子结点 定义1234struct Node&#123; int key; struct Node * parent,*left,*right;&#125;;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建图床上传]]></title>
    <url>%2F2019%2F08%2F19%2F%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[前言picgo 不知道为什么很慢，测试的时候感觉应该是剪贴板的问题，因为我的oss(我用的图床是将阿里云的oss作为自己的图床，没什么访问量 ,按量付费也不贵)上已经有文件了，但是迟迟写不到剪贴板中。并且这个时候通知也会卡。picgo调用通知的地方不止一处，应该不是通知的事情。 对于文件的大小也有很大的区别，如果文件很小，传的也不算慢，但是一旦图片大了，就慢了。也不能排除是picgo调用的网络的事情。 准备因为阿里云的oss有提供命令行的程序，所以写了一个脚本来上传。 下载安装官方文档 安装配置完成后可以直接调用上传文件 如果ossutil64没有设置全局，那shell 要放了同一个目录。 要安装 xclip 用以操作剪贴板 12345678910111213Datetime=$(date "+%Y%m%d%H%M%S")xclip -selection clipboard -t image/jpg -o &gt; ~/$Datetime.jpgif test -s ~/$Datetime.jpg; then kdialog --passivepopup $Datetime.jpg保存成功 --title 提示 ./ossutil64 appendfromfile $Datetime.jpg oss://ossname/img/$Datetime.jpg kdialog --passivepopup $Datetime.jpg上传成功 --title 提示 echo "![](http://yourhost/img/$Datetime.jpg)" | xclip -selection clipboard kdialog --passivepopup 已拷贝到剪贴板http://yourhost/img/$Datetime.jpg --title 提示 rm ~/$Datetime.jpgelse kdialog --passivepopup 请检查剪贴板是否存在图片 --title 错误 rm ~/$Datetime.jpgfi Datetime=$(date &quot;+%Y%m%d%H%M%S&quot;)是作为文件名如20190102123212 xclip -selection clipboard -t image/jpg -o &gt; ~/$Datetime.jpg导出剪贴板中的图片 if test -s ~/$Datetime.jpg; then查看导出的文件大小是否为0，为0的话说明不是图片 kdialog是kde用于弹出通知的，就像这个一样 ./ossutil64 appendfromfile $Datetime.jpg oss://ossname/img/$Datetime.jpg 这一行是用于上传图片的 echo &quot;![](http://yourhost/img/$Datetime.jpg)&quot; | xclip -selection clipboard 是将链接拷贝到剪贴板，因为为将oss进行了域名绑定，所以只有后面的文件名不一样，用变量就可以。 不足我的本意是将快捷键绑定要这个脚本上，但是，不知道为啥成功不了。 进阶每次调用还是有点麻烦，速度上去了，但是操作多了。 用python 写了一个小的用户界面，点一下调用一次shell(最好还是想办法绑定快捷键) 代码1234567891011121314151617181920212223from PyQt5 import QtWidgetsimport sysimport osclass App(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle("阿里云oss上传") self.setFixedSize(100,100) # 设置窗口固定大小 self.main_widget = QtWidgets.QWidget() self.main_layout = QtWidgets.QVBoxLayout() self.main_widget.setLayout(self.main_layout) self.btn_1 = QtWidgets.QPushButton("上传") self.main_layout.addWidget(self.btn_1) self.btn_1.clicked.connect(self.clicks) self.setCentralWidget(self.main_widget) def clicks(self): os.system("/home/yourusername/shot.sh")if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) gui = App() gui.show() sys.exit(app.exec_())]]></content>
      <categories>
        <category>小程序小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>图床</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我错了！kde还是很不错的]]></title>
    <url>%2F2019%2F08%2F12%2Fmanjarokde%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我的manjaro用的是dde的桌面，诚然，非常不错，真的非常不错，就是稍微，启动应用程序慢了点，让我真的有一丢丢的无奈。 无奈下我还是尝试了一下kde的manjaro，前面说过，kde，慢！慢！！慢！！！。 kde启动是真的很慢，但是进了桌面，加载完成之后，其实，感觉，还挺好的，包括各种动画啊啥的都设置好了，启动程序说实话比dde启动程序快的好多，而且动画我也很喜欢。 但是还是遇到了一些问题不知道怎么解决。 全局菜单有时有有时没有，因为先在移动硬盘中装过一个manjaro kde系统，配置运行之后，感觉非常不错，这个全局菜单应该是支持chrome，typora，VScode 等一系列软件的，但是不知道为什么，现在只支持系统原生的了，很奇怪 PicGo上传缓慢，在移动硬盘里面的系统运行时都是秒传的，这一点我也不知道为什么 eclipse报了一个冲突的错误，只要打开.java的文件就报错，没办法，我重装了一次系统。 附上我简单配置的桌面，虽然不好看……]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>kde</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记6——树形结构]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846%EF%BC%9A%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[树结构树结构是一种数据结构，由节点(node)以及链接节点的边构成(edge) 基础概念 根如果一棵树具有一个名为“根”(root)的特殊节点，那么这棵树被叫做有根树(rooted tree) 父结点子结点有根树的节点之间具有父子关系。设一棵有根树T，他的根r到结点x的路径上的最后一条边连接结点p与结点x，此时我们将p称为x的父结点(parent)x称为p在子结点(child) 叶我们将没有子结点的结点称为 外部结点 或者 叶节点 ，其余称为 内部结点 。 度结点的子结点个数称为结点的度 深度从根到x的路径长度称为x的深度，结点x到叶结点的最大路径长度称为结点x的高。根的高称为 树高 二叉树如果一棵树拥有1个根结点，且所有结点的子结点个数都不超过2,那么这棵树称为有根二叉树。 在二叉树中，每个结点的子结点数不超过2个，而且有左右结点之分。也就是说，当某个结点只存在一个子结点时，要严格区分是左结点还是右结点。我们将这各子结点有特定顺序的树称为有序树。 二叉树可以递归进行定义。二叉树条件 T没有任何结点 T由以下三个顶点集合构成 根 左子树 右子树 有根树的表达每个结点u的必要信息 &gt;&gt; u的结点编号 u的结点种类 u的父结点编号 u的子结点列表 u的深度 左子右兄弟表示法信息 结点u的父结点 结点u的最左子结点 结点u的右侧紧邻兄弟结点 结构1struct Node&#123;int parent,int left,int right&#125;; 利用u.parent可以得到各结点u的父结点。不存在父结点的为根。 不存在u.left的结点的为叶。 不存在u.right的结点的为最右侧结点 为表示根及左右结点，将NIL作为特殊结点编号。保证NIL不为一般结点使用 算法 深度 123456getDepth(u) d=0 while T(u).parent!=NIL u=T(u).parent d++ return d 深度(递归) 123456getDepth(u,p) D[u]=p if T[u].right!=NIL getDepth(T[u].right,p) if T[u].left!=NIL getDepth(T[u].left,p+1) 二叉树信息 u的父结点 u的左子结点 u的右子结点 结构1struct Node&#123;int parent,left,right&#125;; 高1234567setHeight(H,u) h1=h2=0 if(Tu).right!=NIL h1=setHeight(H,T[u].right)+1 if(Tu).left!=NIL h2=setHeight(H,T[u].left)+1 return H[u]=max(h1,h2); 具体表达12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#define MAX 10000#define NIL -1struct Node&#123; int parent,left,right;&#125;;struct Node T[MAX];int n,D[MAX],H[MAX];void setDepth(int u,int d)&#123; if(u==NIL) return; D[u]=d; setDepth(T[u].left,d+1); setDepth(T[u].right,d+1);&#125;int setHeight(int u)&#123; int h1=0,h2=0; if(T[u].left!=NIL) h1=setHeight(T[u].left)+1; if(T[u].right!=NIL) h2=setHeight(T[u].right)+1; return H[u]=(h1&gt;h2?h1:h2); &#125;//返回结点u的兄弟结点int getSibling(int u)&#123; if(T[u].parent==NIL) return NIL; if(T[T[u].parent].left!=NIL &amp;&amp; T[T[u].parent].left !=u) return T[T[u].parent].left; if(T[T[u].parent].right!=NIL &amp;&amp; T[T[u].parent].right !=u) return T[T[u].parent].right; return NIL; &#125;void print(int u)&#123; printf("node %d:",u); printf("parent = %d,",T[u].parent); printf("sibling = %d,",getSibling(u)); int deg=0; if(T[u].left!=NIL) deg++; if(T[u].right!=NIL) deg++; printf("degree = %d,",deg); printf("depth = %d",D[u]); printf("height = %d",H[u]); if(T[u].parent==NIL)&#123; printf(" root\n"); &#125;else if(T[u].left==NIL &amp;&amp; T[u].right==NIL)&#123; printf(" leaf\n"); &#125;else&#123; printf(" internal node\n"); &#125;&#125;int main()&#123; int v,l,r,root=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; T[i].parent=NIL; &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d %d %d",&amp;v,&amp;l,&amp;r); T[v].left=l; T[v].right=r; if(l!=NIL) T[l].parent=v; if(r!=NIL) T[r].parent=v; &#125; for (int i = 0; i &lt; n; i++) &#123; if(T[i].parent==NIL) root=i; &#125; setDepth(root,0); setHeight(root); for(int i=0;i&lt;n;i++) print(i); return 0; &#125; 输入1234567891090 1 41 2 32 -1 -13 -1 -14 5 85 6 76 -1 -17 -1 -18 -1 -1 输出结果 树的遍历分类前序遍历根节点、左子树、右子树顺序访问 123456preParse(u) if u == NIL return print u preParse(T[u].left) preParse(T[u].right) 中序遍历左子树、根节点、右子树顺序访问 123456preParse(u) if u == NIL return preParse(T[u].left) print u preParse(T[u].right) 后序访问左子树、右子树、根节点顺序访问 123456preParse(u) if u == NIL return preParse(T[u].left) preParse(T[u].right) print u 子树重建描述给出前序遍历和中序遍历，给出后序遍历 解答12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int n,pos;vector&lt;int&gt; pre, in ,post;void rec(int l, int r)&#123; if(l&gt;=r) return; int root = pre[pos++]; int m=distance(in.begin(),find(in.begin(),in.end(),root)); rec(l,m); rec(m+1,r); post.push_back(root);&#125;void solve()&#123; pos=0; rec(0,pre.size()); for (int i = 0; i &lt; n; i++) &#123; if(i) cout&lt;&lt;" "; cout&lt;&lt;post[i]; &#125; cout&lt;&lt;endl; &#125;int main()&#123; int k; cin&gt;&gt;n; for(int i =0;i&lt;n;i++)&#123; cin&gt;&gt;k; pre.push_back(k); &#125; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;k; in.push_back(k); &#125; solve(); return 0;&#125; 运行结果]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记5——高等排序]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845%EF%BC%9A%E9%AB%98%E7%AD%89%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序过程有些复杂，先来张动图掩饰下尴尬。 过程 将给定的包含n个元素的局部数“分割”成两个局部数组，每个数组各包含$\frac{n}{2}$个元素。（Divide） 对连个局部数组分别执行 mergeSort(归并)排序。(Solve) 通过merge将连个已经排序完成的数组“整合”成一个数组。(Conquer) merge对于merge过程，可以利用已经排好序的前提条件，执行$O(n1+n2)$的算法进行整合。在左半部分（L）和右半部分（R）的末尾分别安插一个 大于所有元素的标记。在比较L、R的元素过程中，只要标记设计的足够大，切将比较次数控制在$n1+n2$($right-left$)之内，就可以防止两个标记相比较。 mergeSortmergeSort 过程中，如果局部数组只剩下一个元素时，mergeSort不做任何处理直接结束。如果不是，则计算局部数组的中央位置mid，将left到mid (不包含) 视作前半部分，mid到right(不包含)视作后半部分。递归套用mergeSort 过程实现流程 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;#define MAX 50000#define SENTINEL 2000000000int L[MAX/2+2],R[MAX/2+2];int cnt;void merge(int A[],int left,int mid,int right)&#123; int n1 = mid - left; //左边的元素数目 int n2 = right -mid; //右边的元素数目 for (int i = 0; i &lt; n1; i++) L[i]=A[left+i]; for (int i = 0; i &lt; n2; i++) R[i]=A[mid+i]; L[n1]=R[n2]=SENTINEL; //设置最大值标志 int i=0,j=0; for(int k=left;k&lt;right;k++)&#123; cnt++; A[k]= L[i]&lt;=R[j]? L[i++]: R[j++]; &#125;&#125;void mergeSort(int A[],int left,int right)&#123; if(left+1&lt;right)&#123; int mid=(left+right)/2; mergeSort(A,left,mid); mergeSort(A,mid,right); merge(A,left,mid,right); &#125;&#125;int main()&#123; int A[MAX],n,i; cnt=0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;A[i]; &#125; mergeSort(A,0,n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;A[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl&lt;&lt;cnt&lt;&lt;endl; return 0; &#125; 运行结果 一共执行34次就完成了排序 快速排序快速排序利用基准值将数组分为两个部分，比基准值小的在基准值前面，比基准值大的在基准值后面。如果基 过程 以整个数组为对象执行quickSort qurickSort过程: 讲数组分割成前后两个局部数组 对前半部分执行quickSort 对后半部分执行quickSort 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define Max 100000#define SENTINEL 2000000000int cnt;int L[Max/2+2],R[Max/2+2];int partition(int A[],int p,int r)&#123; int i,j; int t,x; x=A[r]; i=p-1; for(j=p;j&lt;r;j++)&#123; if(A[j]&lt;x)&#123; cnt++; i++; t=A[i]; A[i]=A[j]; A[j]=t; &#125; &#125; t=A[i+1]; A[i+1]=A[r]; A[r]=t; return i+1;&#125;void quickSort(int A[],int p,int r)&#123; int q; if(p&lt;r)&#123; q=partition(A,p,r); quickSort(A,p,q-1); quickSort(A,q+1,r); &#125;&#125;int main()&#123; int n,i,v; int A[Max]; cnt=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; quickSort(A,0,n-1); for(i=0;i&lt;n;i++)&#123; printf("%d ",A[i]); &#125; printf("\n%d",cnt); return 0;&#125; 如果中间值选的好的话次数大大减少，在上面的同等情况下，快排仅需要20次。 利用标准库排序sortsort的第一个参数制定排序对象开头的迭代器，第二个参数制定末尾的迭代器(排序对象不包含末尾)，对于数组要代入指针。 STL的sort基于快排实现，并且添加了对于最坏情况的应对机制，但是 sort 属于不稳定排序算法 可以用stable_sort 基于归并排序的算法，但是耗费空间大一点，速度稍慢 sort向量代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; vector&lt;int&gt; v; cin &gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; v.push_back(x); &#125; sort(v.begin(),v.end()); for(int i=0;i&lt;v.size();i++)&#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; sort 数组排序123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; int a[100000]; cin &gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; https://images2018.cnblogs.com/blog/941490/201805/941490-20180514224313332-798344959.png https://www.cnblogs.com/onepixel/p/7674659.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro npm换源]]></title>
    <url>%2F2019%2F08%2F06%2Fnpm%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[安装因为要用hexo，所以要安装 nodejs 和 npm 。 在manjaro下 安装十分方便 12sudo pacman -S nodejssudo pacman -S npm 换源npm默认源是国外，相当慢，所以要换成国内的 方法11npm config set registry https://registry.npm.taobao.org 可以通过这条命令验证 1npm config get registry 方法2安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 以后用npm的地方都可以用cnpm替换使用]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 VSCode c/c++环境配置]]></title>
    <url>%2F2019%2F08%2F03%2FVSCode%20c_c%2B%2B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[切换中文安装完成的VSCode是英文的，作为一个英文不好的中国人，我还是喜欢看中文的界面。 点击左侧的 会进入扩展商店 拓展商店中直接搜索Chinese 然后点击Install就行 安装完成后重启应用就会变成中文界面。 安装插件Code Runner 安装完成后窗口菜单栏下面就会出来一个 当你的显示页面是一个程序源文件（单个文件，不是项目）时，点击这个按钮或者按ctrl+F5就可以直接运行这个程序，方便快捷。 点击齿轮，点击配置，然后把右侧的Run In Terminal勾上，就会在控制台显示运行结果 c/c++必装的插件。 C++ IntellisenseC++的只能提示工具 C/C++ Clang Command Adapter提供静态检测（Lint） 配置环境主要是连个json文件 launch.json 点击调试，然后选择添加配置。会自动生成lanunch.json文件 这是我的配置，可以直接复制过去 要注意的就是 &quot;program&quot;: &quot;${workspaceFolder}/hello.out&quot;, //当前目录下编译后的可执行文件 "build"`1234567891011121314151617181920212223242526272829303132这里的hello.out应该是你生成的执行文件，而build 应该是你的tasks的lable```json&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;debug cpp&quot;, //名称 &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/hello.out&quot;, //当前目录下编译后的可执行文件 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, //表示当前目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: false, // 在vscode自带的终端中运行，不打开外部终端 &quot;MIMode&quot;: &quot;gdb&quot;, //用gdb来debug &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;build&quot; //执行lanuch之前运行的task &#125; ]&#125; tasks.json按住ctrl+shift+p 输入tasks，选择configure Task 选择使用模板创建然后选others 就会生成tasks.json文件 仍旧可以直接拷贝 参数应该是自己的，多个文件编译，和在bash中写一样，也可以用makefile 1234567891011121314151617&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "build", // task的名字 "type": "shell", "command": "g++", //编译命令 "args": [ //编译参数列表 "hello.cpp", "-o", "hello.out" ] &#125; ]&#125; c_cpp_properties.json ctrl+shift+p 输入c/c++:Edit Configurations 选择这一项就可以创建一个c_cpp_properties.json文件 不用改动，我也贴出来我的配置 12345678910111213141516&#123; "configurations": [ &#123; "name": "Linux", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [], "compilerPath": "/usr/bin/gcc", "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "gcc-x64" &#125; ], "version": 4&#125; 如果有自己的外链库也是添加到这里面。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro kde 更换 dde 桌面]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjarokde%E6%9B%B4%E6%8D%A2dde%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[当我配置完成一切，各种工具，各种精美的动画效果，炫酷的特效。准备写博客的时候，发现复制到剪贴板中的图片，没有！没有！还是没有！ 上网一查，发现是kde中自带的剪贴板不能保存图片(里面有个设置，不保存图片，我关闭了，还是不行)，无奈下，网上有人说换剪贴板。但是我实在是不会换。 没办法舍弃了一切，放弃kde 安装dde，转了一圈又回来了。（安装deepin的桌面，不是deepin的系统） 1. 下载dde1pacman -S deepin deepin-extra 2.修改配置文件将/etc/lightdm/lightdm.conf中的选项greeter-session设置为lightdm-deepin-greeter 默认是注释掉的，将前面的#删除即可 3.禁用sddm（kde）1systemctl disable sddm 4.启用lightdm1systemctl enable lightdm 5.重启1reboot 6.卸载kde配套相关（可选）123pacman -Rsc plasmapacman -Rsc kde-applications 参考：https://www.jianshu.com/p/a1e31a9a50dc]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro，linux，踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro系统初始配置]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjaro%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[换源更新manjaro中的包管理命令是 pacman 一个十分出色的包管理工具，解决了其他linux 下的安装依赖问题。 常用命令 123pacman -S 软件名 #安装pacman -Syu #更新pacman -R 软件名 #移除 安装完系统，首要就是更新软件和系统，更新之前，要换源，换成中国的源 1sudo pacman-mirrors -i -c China -m rank 这条命令换源到中国，并按速度排序 执行完命令之后会弹出这样的对话框 选择快的，点OK就可以了。 更新一下源 1sudo pacman -Syy 然后更新系统 1sudo pacman -Syyu 个人喜欢vim，先安装一个vim后面要用到 1sudo pacman -S vim 添加archlinuxcn软件源（archlinuxcn是一个中国的软件源，包含了很多常用的中文软件和工具） 1sudo vim /etc/pacman.conf 在文件最下面添加 12[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 更新软件源并导入公钥 1sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 系统的初始配置就做好了 安装软件管理工具manjaro中带有图形管理工具，可以完成应用的安装，删除，检索等操作，我系统在现在是KDE的管理工具 个人感觉不如gonme中的好用，但是却不知道怎么更换，没办法了。 安装yaourt（有些东西pacman装不了）1sudo pacman -S yaourt 安装 chrome1sudo pacman -S google-chrome 安装截图工具1sudo pacman -S deepin-screenshot 安装QQ1sudo pacman -S deepin.com.qq.im 安装TIM(kde下不好装QQ，TIM还好)1sudo pacman -S deepin.com.qq.office 安装网易云音乐1sudo pacman -S netease-cloud-music 安装搜狗输入法123sudo pacman -S fcitx-imsudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyin 添加输入法配置文件 sudo vim ~/.xprofile 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx" 可以进行各种配置 配置完需要重启计算机 安装 markdown 编辑器不得不说比deepin安装得方便 1sudo yaourt typora 安装vscode1sudo pacman -S visual-studio-code-bin 安装eclipse1sudo pacman -S eclipse 安装WPS1sudo pacman -S ttf-wps-fonts 图床工具PicGo如果对图床工具有需要的话 直接到官网下载AppImage文件，双击就可以用了 到此为止，常用的软件都已经装上了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>系统配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro安装]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjaro%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[制作启动盘安装系统,最先就要制作启动盘嘛. 推荐以 dd 模式写入(不分系统区与数据区) 在进入U盘的时候一定要bios的安全启动(Secure Boot) 关闭(Disabled)不然进不去系统. 安装系统然后就可以看到这个界面 如果你是双显卡的电脑，driver这里一定要设置为no-free，不然装好了之后，是黑屏。 进入系统后会出现这个界面。从左上角可以选择语言，点击 启动安装程序 就可以进入系统安装界面了 一步步设置下去。 如果像我一样，在移动硬盘中安装，一定要注意: **硬盘是GPT格式！！！ 硬盘是GPT格式！！！ 硬盘是GPT格式！！！ 不然这里没有你的移动硬盘出现（我为什么知道？我都被逼疯了我会不知道！？） 选择硬盘你可以自己选择挂载，也可直接全盘安装，都可以。然后就等待就可以了。 因后写的经历，当初没来得及截图，图片来源： https://cloud.tencent.com/developer/article/1390999 https://www.cnblogs.com/smlile-you-me/p/8830949.html https://zhidao.baidu.com/question/2144265946313985668.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>搞系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本机配置]]></title>
    <url>%2F2019%2F08%2F01%2Fgit%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置用户名和邮箱12git config --global user.name yourUserNamegit config --global user.email yourEmail@email 生成SSH秘钥1ssh-keygen -t rsa -C "YourEmail" #注意引号 会在用户的目录下生成一个.ssh的文件夹 文件夹里面有两个文件，一个公钥一个私钥，需要讲公钥放到 github里面，才可以用本机访问github上自己的文件 将秘钥复制到github 这就是秘钥 登录github在 左侧一列中选择 然后点击 复制进来刚才的秘钥就可以了 验证输入命令 1ssh -T git@github.com 中间会问你一次，回答yes就行， 如果提示最后一行，就说明你成功了！！！ 如果提示 12sign_and_send_pubkey: signing failed: agent refused operationPermission denied (publickey). 请查看博客 git 配置后 ssh -T git@github.com出错]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>git</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro linux 安装总结]]></title>
    <url>%2F2019%2F08%2F01%2Fmanjaro%20linux%20%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[折腾了好几天，从deepin 到 manjaro 折腾好几天终于可以说是勉强弄好了（搞累了，不想搞了） 没有前面的可能没有任何截图 deepindeepin 一开始再B站上看见了他的UI ，感觉挺漂亮，就往打算装了移动硬盘里。 因为不喜欢开机选择系统，也不想放弃windows , 第一次往移动硬盘里面装，不知道会不会把引导写进我的系统里面，我就把电脑本身的两个硬盘都拆卸了下来（原谅我的怂）。 装好之后，确实很漂亮，也让我很喜欢，但是最新版本中极力吹鼓的云同步功能却说我不在他们的服务范围内（WTF！？）虚拟机里还能用，一番百度，看论坛，也没有看到解决办法，还好，云同步并不是那么重要暂时，不要就不要吧。 一番操作猛如虎，终于完成了基础工作的配置，下面的dock非常不错，但是没有mac中的特效， 这个启动器也是非常不错的体验 好吧，，，这个截图是我现在系统的截图，manjao用的dde的桌面…… deepin 我一共装了两回，崩了两次。 第一次是更新系统 ，好吧，是我等不及，他一直更新不完我就重启了，然后就进不了系统界面了，输入密码之后是黑屏……无奈重装，可怜我一晚上的部署操作。 第二次是卸载软件，我应该是不太专业……不知道卸载了什么，反正突然系统自带的应用丢了一大部分，深度应用商店，深度截图，深度……都没了。 这一次装的时候，懒得拆硬盘了，直接选中移动硬盘，全盘安装，很幸运，引导卸载了移动硬盘中。 无奈下，弃坑，转投manjaro manjaromanjaro 说实话，在用之前我真不知道还有这么个系统，之前听别人提到的时候我以为是和docker类似的什么环境。 manjaro采用滚动式升级，升级系统不用重装，也可以回滚，个人感觉很不错 manjaro 几乎涵盖了所有主流的桌面系统，gonme，kde，dde等等 第一次安装了一个自带gonme的manjaro，个人感觉还是很不错的，但是在本人手残的一系列操作下，gonme还是崩溃了，至少我不知道怎么把他变回原样了，我选择重装 重装了一个kde的桌面，第一次进系统，不得不说，真的…… ………… 好慢啊………… ………… 但是kde的ui是真的漂亮，仿mac做的很好，各种窗口的动画我也非常喜欢。 但是很受不了的是，kde自带的剪贴板存不了图片,这真的很让人头疼，我想到了换剪贴板，但是多方查阅资料后，我发现，还是不会换。 无奈下我选择了重装桌面，只重装桌面，安装dde（没错，就是深度）然后将kde卸载。 但是回到dde后发现，，，，kde的动画真好看，dde的ui虽然不错但是kde动画真好看 对了 kde 对于qq好像不是很支持，安装qq的时候安装的很费劲。 这就是我现在的桌面了 经过了长达两三天，无数次的重装，终于得到了一个稍微满意的系统。 中间猜的坑，会单独做总结。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>踩坑经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin linux 下安装Typora]]></title>
    <url>%2F2019%2F07%2F29%2Fdeepin%20linux%20%E4%B8%8B%E5%AE%89%E8%A3%85Typora%2F</url>
    <content type="text"><![CDATA[一直喜欢Typora，刚刚装了deepin Linux ，打算安装一下，但是照着官网给出的教程，却总是报错 123456sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora 这是官网给出的教程，但是在第一步就报错，报了两个文件缺失的错误，当时没有截下图来。 之后执行 1sudo apt-get install dirmngr 就可以了 但是在执行第二行的时候也报错，这里有两个解决办法 1sudo add-apt-repository 'deb https://typora.io/linux ./‘ 方法一： 1sudo vim /etc/apt/sources.list 然后手动添加sudo add-apt-repository ‘deb https://typora.io/linux ./”（不带双引号） 方法二：需要安装 12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 但是 依赖有问题 1sudo aptitude install python-software-properties 同理 1sudo aptitude install software-properties-common 然后运行 123sudo add-apt-repository ‘deb https://typora.io/linux ./’ sudo apt-get update sudo apt-get install typora 就可以完成安装 执行 1typora 就可以运行了]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git添加公钥后报错sign_and_send_pubkey]]></title>
    <url>%2F2019%2F07%2F28%2Fgit%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%90%8E%E6%8A%A5%E9%94%99sign_and_send_pubkey%20signing%20failed%2F</url>
    <content type="text"><![CDATA[错误描述当在github上添加公钥之后运行ssh -T git@github.com 提示错误： 12sign_and_send_pubkey: signing failed: agent refused operationPermission denied (publickey). 解决办法12eval "$(ssh-agent -s)"ssh-add]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>git</tag>
        <tag>经验</tag>
        <tag>错误解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构-笔记4-递归与分治]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B04-%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[递归递归是指自己调用自己的函数。 如下面的阶乘递归 12345fact(int n)&#123; if(n==1) return n; return fact(n-1)*n;&#125; 递归函数必须要设置出口，也就是上面的 12if(n==1) return n; 分治分治的过程 将问题分割成局部问题(Divide) 递归地求解局部问题(Solve) 将局部问题的解整合成原问题的解(Conquer) 搜索： 1234567891011findMax(int A[],l,r)&#123; int m; int u,v; m=(l+r)/2; if(l==r-1)&#123; return A[l] &#125;else&#123; u=findMax(A,l,m) &#125; &#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记2——数据结构]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[概述栈(Stack)规则后入先出（Last In First Out,LIFO） 操作 push(X)：在栈的顶部压入元素X pop(): 从栈的顶部取出元素 isEmpty()：检查栈是否为空 isFull(): 检查栈是否已满 一般情况下，栈还具有 “引用栈顶元素”和”检查栈中是否含有指定数据“的操作 队列(Queue)规则先入先出（First In First Out） 操作 enqueue(x)：在队列的末端添加元素x dequeue(): 从队列开头取出元素 isEmpty(): 检查队列是否为空 isFull()：检查队列是否已满 一般情况下，队列还具有 “引用队列第一个元素”和”检查队列中是否含有指定数据“的操作 应用逆波兰表示法(栈的应用)逆波兰表示法是一种将操作符写在操作数后面的方法，又叫后缀表示法，相较于我们日常使用的中缀表示法**，它的优势在于不需要括号 例：$（1+2）\times (5+4) $ ==&gt;&gt;$1\space 2 + 5\space 4 + \times $ 将 1 2 压入栈中 遇到运算符，从栈中取出两个操作数，按运算符运算，例中为+，将运算结果压入栈中，栈中数据变成了 3 将 5 4 压入栈中，栈中数据变为了 3 5 4 遇到操作符+ 取出两个操作数5 4 运算结果为9，压入栈中，栈中变为3 9 遇到操作符$\times$ 取出3 9 运算结果为27 一个并不完善的简单过程 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//本程序仅支持0-9的数字运算int top,stack[1000];void push(int x)&#123; stack[++top]=x;&#125;int pop()&#123; return stack[top--];&#125;int main()&#123; char s[1000]; int i,a,b; i=0; top=0; scanf("%s",s); while(s[i]!='\0')&#123; if(s[i]=='+')&#123; a=pop(); b=pop(); push(a+b); &#125;else if(s[i]=='-')&#123; a=pop(); b=pop(); push(a-b); &#125;else if(s[i]=='*')&#123; a=pop(); b=pop(); push(a*b); &#125;else if(s[i]=='/')&#123;//整除结果 a=pop(); b=pop(); push(a/b); &#125;else &#123; push(s[i]-48); &#125; i++; &#125; printf("%d",pop()); return 0;&#125; 运行结果： 队列12345678910111213141516171819202122232425262728293031323334353637383940现有名称为namei且处理时间为timei的n个任务按照顺序排成一列，CPU通过循环调度法逐一处理这些任务，每个任务最多处理q ms(这个时间称为时间片)。如果q ms之后任务尚未处理完毕，那么该任务将被移动至队伍最末尾，CPU随即开始处理下一个任务 举个例子，假设q是100，然后有如下任务队列。 A(150) -- B(80) -- C(200) -- D(200) 首先A被处理100 ms，然后带着剩余的50 ms移动至队尾 B(80) -- C(200) -- D(200) -- A(50) 随后B被处理80 ms，在总计第180 ms时完成处理，从队列中消失 C(200) -- D(200) -- A(50) 接下来C被处理100 ms，然后带着剩余的100 ms移动至队尾。 D(200) -- A(50) -- C(100) 之后同理，一直循环到处理完所有任务。 请编写一个程序，模拟循环调度法。输入 输入形式如下 n q name1 time1 name2 time2 ... namen timen 第一行输入表示任务数的整数n与时间片的整数q，用一个空格隔开 接下来n行输入各任务的信息。字符串namei与timei用一个空格隔开。输出 按照任务完成的先后顺序输出各任务名以及结束时间，任务名与对应结束时间用空格隔开， 每一对任务名与结束时间占一行。限制 1 ≤n ≤100 000 1 ≤q ≤1000 1 ≤timei ≤50 000 1 ≤字符串namei的长度 ≤10 1 ≤timei的和 ≤1 000 000 输入示例 输出示例 5 100 p2 180 p1 150 p5 400 p2 80 p1 450 p3 200 p3 350 p4 350 p4 800 p5 20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;/* 以数组实验队列 */#define MAX 100005long tail ,head ; //头尾元素位置typedef struct queue&#123; char name[10]; long time;&#125;q;q Q[MAX];int isEmpty()&#123; if(tail==head) return 1; return 0;&#125;int isFull()&#123; if (tail+1==head) return 1; return 0;&#125;void enqueue(q p)&#123; if(!isFull())&#123; Q[tail]=p; tail=(tail+1)%MAX; &#125;&#125;q dequeue()&#123; q p; if(!isEmpty())&#123; p=Q[head]; head=(head+1)%MAX; &#125; return p;&#125;int main()&#123; tail=head=0; long elaps=0; int i=0; q u; long n,qtime; scanf("%ld %ld",&amp;n,&amp;qtime); while(i&lt;n)&#123; scanf("%s %ld",u.name,&amp;u.time); enqueue(u); i++; &#125; while(!isEmpty())&#123; u=dequeue(); if (u.time-qtime&lt;=0) &#123; elaps+=u.time; printf("%s %ld\n",u.name,elaps); continue; &#125; elaps+=qtime; u.time-=qtime; enqueue(u); &#125;&#125; 运行结果: STL(C++标准库)C++库以提供“模板”为主，是指不必预先制定类型的函数或类。 STL为用户提供了多种名为辅容器（Container）的类，用于管理数据集合。在创建动态数组、表、栈、队列等结构时，只需要定义对应的容器。然后就可以通过调用成员函数或方法使用。 stack 函数名 功能 复杂度 size() 返回栈的元素数 O(1) top() 返回栈顶元素 O(1) pop() 从栈中取出并删除元素 O(1) push(x) 向栈中添加元素x O(1) empty() 当栈为空时返回true O(1) 1234567891011121314151617#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; S; S.push(1); S.push(2); S.push(3); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl; S.pop(); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl;&#125; 运行结果： 通过栈模板实现逆波兰表示 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int i=0,a,b; string s; stack&lt;int&gt; stk; cin&gt;&gt;s; while (s[i]!='\0') &#123; switch(s[i])&#123; case '+': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a+b); break; case '-': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a-b); break; case '*': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a*b); break; default: stk.push(s[i]-48); &#125; i++; &#125; cout&lt;&lt;stk.top()&lt;&lt;endl; return 0;&#125; 运行结果： queue 函数名 功能 复杂度 size() 返回队列中的元素数目 O(1) front() 返回队头的元素 O(1) pop() 从队列中取出并删除元素 O(1) push(x) 在队列中添加元素x O(1) empty() 当队列为空时返回true O(1) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;string&gt; que; que.push("red"); que.push("yellow"); que.push("yellow"); que.push("blue"); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); return 0;&#125; 运行结果： 用标准库模板实现上面的队列 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;pair&lt;string,int&gt;&gt; que; string name; int n,q,t; int elaps=0; cin&gt;&gt;n&gt;&gt;q; while(n--)&#123; cin&gt;&gt;name&gt;&gt;t; que.push(make_pair(name,t)); &#125; pair&lt;string,int&gt; u; while(!que.empty()) &#123; u=que.front(); que.pop(); if(u.second-q&lt;=0)&#123; elaps+=u.second; cout&lt;&lt;u.first&lt;&lt;' '&lt;&lt;elaps&lt;&lt;endl; continue; &#125; u.second-=q; elaps+=q; que.push(u); &#125; return 0;&#125; 运行结果： pair是保存对数值的结构体模板，声明时需要在&lt;&gt;中指令两个数据结构。make_pair用于生成一对数值，第一个元素通过first访问，第二个通过second访问 vector可以在添加元素是增加长度的数组成为动态数组或可变长数组。相对地，必须事先指定长度的是静态数组 STL中的vector（向量）实现了动态数组 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) pop_back() 删除向量的最后一个元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(n) erase(p) 删除向量中迭代器p指向的元素 O(n) clear() 删除向量中所有元素 O(n) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;void output(vector&lt;double&gt; v)&#123; for (int i = 0; i &lt; v.size(); i++) &#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;int main()&#123; vector&lt;double&gt; vec; vec.push_back(0.1); vec.push_back(0.2); vec.push_back(0.3); vec[2]=0.4; output(vec); vec.insert(vec.begin()+2,0.8); output(vec); vec.erase(vec.begin()+1); output(vec); return 0;&#125; 输出结果： listlist是一个双向列表 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) push_front(x) 在向量的开头添加x O(1) pop_back() 删除向量的最后一个元素 O(1) pop_front() 删除向量的开头元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(1) erase(p) 删除向量中迭代器p指向的元素 O(1) clear() 删除向量中所有元素 O(n) 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;int main()&#123; list&lt;char&gt; li; li.push_back('b'); //[b] li.push_front('a'); //[ab] li.push_back('c'); //[abc] cout&lt;&lt;li.front(); //a cout&lt;&lt;li.back(); //c li.pop_front(); //[bc] li.push_back('d'); //[bcd] cout&lt;&lt;li.front(); //b cout&lt;&lt;li.back(); //d return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记3——搜索]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B03-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[概述搜索是从数据集合中找出目标元素的处理。 graph LR A{搜索} -->B(线性搜索) A--> C(二分搜索) A--> E(散列) 线性搜索线性搜索是从数组开头顺次访问个元素，检查给该元素是否与目标值相等。相等则返回元素位置并结束搜索。如果检查完数组还没有发现目标值，则返回一个特殊值来说明。线性搜索的算法效率很低，但适用于任何形式的数据。 二分搜索二分搜索算法可以利用数据的大小进行高速搜索。二分搜索的前提是 已经排序。 思路： 将整个数组（升序）作为搜索范围 检查位于搜索范围正中央的元素 如果一致则结束 如果不一致则比较大小，小于的话，以前半部分为搜索范围执行第二步。否则以后半部分为范围执行。 如果到最后没找到，就返回特定值，表示未找到 散列法在散列法中，各元素的存储位置由散列函数决定。散列既是一种数据结构，同时也是一种使用散列表的算法。只需要将关键字（key）带入就可得到对应位置。搜索效率很高。 线性搜索题目请编写一个程序，输入包含 n 个整数的数列 s 以及包含 q 个不重复整数数列 T ，输出既包含于 T 又包含于 S 的整数个数 c 输入： 第一行输入 n，第二行输入代表 S 的 n 个整数，第三行输入 q，第四行输入代表 T 的 q 个整数。 输出：用1行输出C 限制： $n\leq1000$，$q\leq500$ ，$0\leq{S,T的元素}\leq{10^9}$，T中元素不重复 输入示例: 123451 2 3 4 533 4 1 输出示例： 13 程序123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int i=0; A[n]=key;//通过将最后一个置为key的方法，引入标记，可以提升效率，在处理大数据的时候会有显著效果 while(A[i]!=key) i++; return i!=n;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 输出结果 因为线性搜索的算法复杂度为$O(n)$，所以算法的复杂度$O(qn)$ 二分搜索对于含有 n 个元素的素组执行线性搜索以及二分搜索时，最坏的情况下运算次数如下 元素数 线性搜索 二分搜索 100 100 7 10000 10000 14 1000000 1000000 20 最坏情况下二分搜索的复杂度大概是$log_2n$ 题目同上题，假设输入有序数列 程序123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int left=0; int right=n-1; int mid; while(left&lt;right)&#123; mid=(left+right)/2; if(key==A[mid]) return 1; if(key&gt;A[mid])left=mid+1; else right=mid-1; &#125; return 0;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 运行结果： 散列法不同于数组的下标索引，可以通过键值直接查到对应值，每一个键值都有一个唯一对应的值 数组索引 a[0],a[1],a[2]…… 散列 a[key0],a[key1],a[key2]…… 方法： 通过散列函数在键值与值之间建立一个对应的函数关系Hash() 存储位置可以通过 address=Hash(key) 的方式运算出来 在插入和搜索时通过步骤2的方式可以迅速得出键值对应值的存储位置 散列函数方法中步骤1中所涉及的函数关系叫做散列函数 散列函数在使用的时候应该注意： 简单，快速的可以计算出结果 在双散列结构中，当多个键值的散列值相同时，即冲突发生时，可以调用hash1() hash2() hash3()……等一系列散列函数得到不同的散列值 STL迭代器迭代器是一种对象，可以对容器中对象进行迭代处理，指向容器中的位置 可以使用的运算符 运算符 效果 ++ 指向下一个迭代器 ==，!= 判断两个迭代器指向位置是否相等 = 将运算符右侧迭代器赋值给左侧迭代器 * 返回该位置元素 容器函数 函数名 效果 begin() 返回容器的开头元素 end() 返回容器的最后一个元素 1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; int i; for(i=0;i&lt;10;i++)&#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator iter; for(iter=v.begin();iter!=v.end();iter++)&#123; cout&lt;&lt;*iter&lt;&lt;" "; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记1]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[基础篇基础概念复杂性评估 时间复杂度：评估执行程序所需要的时间。可以估算出程序对计算机处理器的使用程序 空间复杂度：评估执行程序 所需的存储空间。可以估算出程序 对计算机内存的使用程度 “复杂度”大多数情况下是指的时间复杂度 大O表示法：大O表示法是一种评估算法效率的“标尺”，以诸如$O(n)$、$ O(n^2)$的形式表示算法的效率，其中n为问题的数据大小。 常用的复杂度比较 $ n $ $ log(n) $ $ \sqrt n$ $ nlog(n) $ $ n^2 $ $ 2^n $ $ n! $ 5 2 2 10 25 32 120 10 3 3 30 100 1024 3628800 20 4 4 80 400 1048576 约$ 2.4 \times 10^{18}$ 50 5 7 250 2500 约$ 10^{15}$ 约$ 3 \times 10^{64}$ 100 6 10 600 10000 约$ 10^{30}$ 约$ 9.3\times 10^{157}$ 1000 9 31 9000 $ 10^6$ 约$ 10^{300}$ 约$ 4 \times 10^{2567}$ $10^4$ 13 100 $ 1.3\times 10^{5}$ $ 10^9$ 约$ 10^{3000}$ 约$ 10^{35660}$ $10^5$ 16 316 $ 1.6 \times 10^{6}$ $ 10^{10}$ 约$ 10^{30000}$ 约$ 10^{456574}$ $ 10^6$ 19 100 $ 1.9 \times 10^{7}$ $ 10^{12}$ 约$ 10^{300000}$ 约$ 10^{5565709}$ 稳定排序是指在出现多次相同数据时，能保证稳定输出的排序算法 初等排序 排序 最好 最坏 稳定情况 插入排序 N（有序） $O(N^2)$ 稳定 冒泡排序 $O(N)$ $O(N^2)$ 稳定 选择排序 $O(N^2)$ $O(N^2)$ 不稳定 希尔排序 $O(N)$ $O(N^2)$ 不稳定 插入排序 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 1234567891011121314151617void InsertSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) &#123; int j=i-1; if(a[i]&lt;a[i-1])&#123; //若第i个元素小于第i-1个元素,移动有序序列插入------大于的话则直接插入 int swap=a[i]; //存储将要排序的元素 a[i]=a[i-1]; //向后移动一个元素 while(swap&lt;a[j])//查询将要插入的位置 &#123; a[j+1]=a[j]; j--; //元素后移 &#125; a[j+1]=swap;//循环结束 插入到指定位置 &#125; &#125;&#125; 冒泡排序 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213#include&lt;stdio.h&gt;void BuddleSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; for( int j=0;j&lt;n-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; int swap=a[j]; a[j]=a[j+1]; a[j+1]=swap; &#125; &#125; &#125;&#125; 选择排序步骤： 未排序序列中找到最小元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 以此类推，直到所有元素均排序完毕。 1234567891011121314151617181920void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; int min=i; //存放数组最小值的位置 for(int j=i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[min])&#123; min=j; //找出最小值，并记录位置 &#125; &#125; if(min!=i) //最小元素与第i个元素互换位置 &#123; int swap=a[min]; a[min]=a[i]; a[i]=swap; &#125; &#125;&#125; 希尔排序步骤： 选取间隔为g的元素进行插入排序 缩小g的范围，新的g与原g互质 重复执行步骤1，2 最后选取g=1执行一次插入排序 1234567891011121314151617insertionSort(A,n,g)&#123; for i = g to n-1 v=A[i] j=i-g while j&gt;=0 &amp;&amp; A[j]&gt;v A[j+g]=a[j] j=j-g cnt++ A[j+g]=v&#125;shellSort(A,n)&#123; cnt=0; m=?; g[]=&#123;……,1&#125;; for i=0 to m-1 insertionSort(A,n,g[i])&#125; 注： 最后一定要执行一次g=1的普通 插入排序 ，确保正确 参考教材：《挑战程序设计竞赛2 算法数据结构》 参考资料：https://www.cnblogs.com/xaimicom/p/9189471.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
