<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git本机配置]]></title>
    <url>%2F2019%2F08%2F01%2Fgit%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置用户名和邮箱12git config --global user.name yourUserNamegit config --global user.email yourEmail@email 生成SSH秘钥1ssh-keygen -t rsa -C "YourEmail" #注意引号 会在用户的目录下生成一个.ssh的文件夹 文件夹里面有两个文件，一个公钥一个私钥，需要讲公钥放到 github里面，才可以用本机访问github上自己的文件 将秘钥复制到github 这就是秘钥 登录github在 左侧一列中选择 然后点击 复制进来刚才的秘钥就可以了 验证输入命令 1ssh -T git@github.com 如果是第一次可能问你是yes/no 回答yes 然后提示 1Hi yourname! You've successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！！！]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro linux 安装总结]]></title>
    <url>%2F2019%2F08%2F01%2Fmanjaro%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[折腾了好几天，从deepin 到 manjaro 折腾好几天终于可以说是勉强弄好了（搞累了，不想搞了） 没有前面的可能没有任何截图 deepindeepin 一开始再B站上看见了他的UI ，感觉挺漂亮，就往打算装了移动硬盘里。 因为不喜欢开机选择系统，也不想放弃windows , 第一次往移动硬盘里面装，不知道会不会把引导写进我的系统里面，我就把电脑本身的两个硬盘都拆卸了下来（原谅我的怂）。 装好之后，确实很漂亮，也让我很喜欢，但是最新版本中极力吹鼓的云同步功能却说我不在他们的服务范围内（WTF！？）虚拟机里还能用，一番百度，看论坛，也没有看到解决办法，还好，云同步并不是那么重要暂时，不要就不要吧。 一番操作猛如虎，终于完成了基础工作的配置，下面的dock非常不错，但是没有mac中的特效， 这个启动器也是非常不错的体验 好吧，，，这个截图是我现在系统的截图，manjao用的dde的桌面…… deepin 我一共装了两回，崩了两次。 第一次是更新系统 ，好吧，是我等不及，他一直更新不完我就重启了，然后就进不了系统界面了，输入密码之后是黑屏……无奈重装，可怜我一晚上的部署操作。 第二次是卸载软件，我应该是不太专业……不知道卸载了什么，反正突然系统自带的应用丢了一大部分，深度应用商店，深度截图，深度……都没了。 这一次装的时候，懒得拆硬盘了，直接选中移动硬盘，全盘安装，很幸运，引导卸载了移动硬盘中。 无奈下，弃坑，转投manjaro manjaromanjaro 说实话，在用之前我真不知道还有这么个系统，之前听别人提到的时候我以为是和docker类似的什么环境。 manjaro采用滚动式升级，升级系统不用重装，也可以回滚，个人感觉很不错 manjaro 几乎涵盖了所有主流的桌面系统，gonme，kde，dde等等 第一次安装了一个自带gonme的manjaro，个人感觉还是很不错的，但是在本人手残的一系列操作下，gonme还是崩溃了，至少我不知道怎么把他变回原样了，我选择重装 重装了一个kde的桌面，第一次进系统，不得不说，真的…… ………… 好慢啊………… ………… 但是kde的ui是真的漂亮，仿mac做的很好，各种窗口的动画我也非常喜欢。 但是很受不了的是，kde自带的剪贴板存不了图片,这真的很让人头疼，我想到了换剪贴板，但是多方查阅资料后，我发现，还是不会换。 无奈下我选择了重装桌面，只重装桌面，安装dde（没错，就是深度）然后将kde卸载。 但是回到dde后发现，，，，kde的动画真好看，dde的ui虽然不错但是kde动画真好看 对了 kde 对于qq好像不是很支持，安装qq的时候安装的很费劲。 这就是我现在的桌面了 经过了长达两三天，无数次的重装，终于得到了一个稍微满意的系统。 中间猜的坑，会单独做总结。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>踩坑经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin linux 下安装Typora]]></title>
    <url>%2F2019%2F07%2F29%2Fdeepin%20linux%20%E4%B8%8B%E5%AE%89%E8%A3%85Typora%2F</url>
    <content type="text"><![CDATA[一直喜欢Typora，刚刚装了deepin Linux ，打算安装一下，但是照着官网给出的教程，却总是报错 123456sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora 这是官网给出的教程，但是在第一步就报错，报了两个文件缺失的错误，当时没有截下图来。 之后执行 1sudo apt-get install dirmngr 就可以了 但是在执行第二行的时候也报错，这里有两个解决办法 1sudo add-apt-repository 'deb https://typora.io/linux ./‘ 方法一： 1sudo vim /etc/apt/sources.list 然后手动添加sudo add-apt-repository ‘deb https://typora.io/linux ./”（不带双引号） 方法二：需要安装 12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 但是 依赖有问题 1sudo aptitude install python-software-properties 同理 1sudo aptitude install software-properties-common 然后运行 123sudo add-apt-repository ‘deb https://typora.io/linux ./’ sudo apt-get update sudo apt-get install typora 就可以完成安装 执行 1typora 就可以运行了]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git添加公钥后报错sign_and_send_pubkey]]></title>
    <url>%2F2019%2F07%2F28%2Fgit%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%90%8E%E6%8A%A5%E9%94%99sign_and_send_pubkey%3A%20signing%20failed%3A%20%E2%80%A6%E2%80%A6%2F</url>
    <content type="text"><![CDATA[错误描述当在github上添加公钥之后运行ssh -T git@github.com 提示错误： 12sign_and_send_pubkey: signing failed: agent refused operationPermission denied (publickey). 解决办法12eval "$(ssh-agent -s)"ssh-add]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
        <tag>git</tag>
        <tag>错误解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构-笔记4-递归与分治]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B04-%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[递归递归是指自己调用自己的函数。 如下面的阶乘递归 12345fact(int n)&#123; if(n==1) return n; return fact(n-1)*n;&#125; 递归函数必须要设置出口，也就是上面的 12if(n==1) return n; 分治分治的过程 将问题分割成局部问题(Divide) 递归地求解局部问题(Solve) 将局部问题的解整合成原问题的解(Conquer) 搜索： 1234567891011findMax(int A[],l,r)&#123; int m; int u,v; m=(l+r)/2; if(l==r-1)&#123; return A[l] &#125;else&#123; u=findMax(A,l,m) &#125; &#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记3——搜索]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B03-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[概述搜索是从数据集合中找出目标元素的处理。 1234graph LRA&#123;搜索&#125; --&gt;B(线性搜索)A--&gt; C(二分搜索)A--&gt; E(散列) 线性搜索线性搜索是从数组开头顺次访问个元素，检查给该元素是否与目标值相等。相等则返回元素位置并结束搜索。如果检查完数组还没有发现目标值，则返回一个特殊值来说明。线性搜索的算法效率很低，但适用于任何形式的数据。 二分搜索二分搜索算法可以利用数据的大小进行高速搜索。二分搜索的前提是 已经排序。 思路： 将整个数组（升序）作为搜索范围 检查位于搜索范围正中央的元素 如果一致则结束 如果不一致则比较大小，小于的话，以前半部分为搜索范围执行第二步。否则以后半部分为范围执行。 如果到最后没找到，就返回特定值，表示未找到 散列法在散列法中，各元素的存储位置由散列函数决定。散列既是一种数据结构，同时也是一种使用散列表的算法。只需要将关键字（key）带入就可得到对应位置。搜索效率很高。 线性搜索题目请编写一个程序，输入包含 n 个整数的数列 s 以及包含 q 个不重复整数数列 T ，输出既包含于 T 又包含于 S 的整数个数 c 输入： 第一行输入 n，第二行输入代表 S 的 n 个整数，第三行输入 q，第四行输入代表 T 的 q 个整数。 输出：用1行输出C 限制： $n\leq1000$，$q\leq500$ ，$0\leq{S,T的元素}\leq{10^9}$，T中元素不重复 输入示例: 123451 2 3 4 533 4 1 输出示例： 13 程序123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int i=0; A[n]=key;//通过将最后一个置为key的方法，引入标记，可以提升效率，在处理大数据的时候会有显著效果 while(A[i]!=key) i++; return i!=n;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 输出结果 因为线性搜索的算法复杂度为$O(n)$，所以算法的复杂度$O(qn)$ 二分搜索对于含有 n 个元素的素组执行线性搜索以及二分搜索时，最坏的情况下运算次数如下 元素数 线性搜索 二分搜索 100 100 7 10000 10000 14 1000000 1000000 20 最坏情况下二分搜索的复杂度大概是$log_2n$ 题目同上题，假设输入有序数列 程序123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int left=0; int right=n-1; int mid; while(left&lt;right)&#123; mid=(left+right)/2; if(key==A[mid]) return 1; if(key&gt;A[mid])left=mid+1; else right=mid-1; &#125; return 0;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 运行结果： 散列法不同于数组的下标索引，可以通过键值直接查到对应值，每一个键值都有一个唯一对应的值 数组索引 a[0],a[1],a[2]…… 散列 a[key0],a[key1],a[key2]…… 方法： 通过散列函数在键值与值之间建立一个对应的函数关系Hash() 存储位置可以通过 address=Hash(key) 的方式运算出来 在插入和搜索时通过步骤2的方式可以迅速得出键值对应值的存储位置 散列函数方法中步骤1中所涉及的函数关系叫做散列函数 散列函数在使用的时候应该注意： 简单，快速的可以计算出结果 在双散列结构中，当多个键值的散列值相同时，即冲突发生时，可以调用hash1() hash2() hash3()……等一系列散列函数得到不同的散列值 STL迭代器迭代器是一种对象，可以对容器中对象进行迭代处理，指向容器中的位置 可以使用的运算符 运算符 效果 ++ 指向下一个迭代器 ==，!= 判断两个迭代器指向位置是否相等 = 将运算符右侧迭代器赋值给左侧迭代器 * 返回该位置元素 容器函数 函数名 效果 begin() 返回容器的开头元素 end() 返回容器的最后一个元素 1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; int i; for(i=0;i&lt;10;i++)&#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator iter; for(iter=v.begin();iter!=v.end();iter++)&#123; cout&lt;&lt;*iter&lt;&lt;" "; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记2——数据结构]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[概述栈(Stack)规则后入先出（Last In First Out,LIFO） 操作 push(X)：在栈的顶部压入元素X pop(): 从栈的顶部取出元素 isEmpty()：检查栈是否为空 isFull(): 检查栈是否已满 一般情况下，栈还具有 “引用栈顶元素”和”检查栈中是否含有指定数据“的操作 队列(Queue)规则先入先出（First In First Out） 操作 enqueue(x)：在队列的末端添加元素x dequeue(): 从队列开头取出元素 isEmpty(): 检查队列是否为空 isFull()：检查队列是否已满 一般情况下，队列还具有 “引用队列第一个元素”和”检查队列中是否含有指定数据“的操作 应用逆波兰表示法(栈的应用)逆波兰表示法是一种将操作符写在操作数后面的方法，又叫后缀表示法，相较于我们日常使用的中缀表示法**，它的优势在于不需要括号 例：$（1+2）\times (5+4) $ ==&gt;&gt;$1\space 2 + 5\space 4 + \times $ 将 1 2 压入栈中 遇到运算符，从栈中取出两个操作数，按运算符运算，例中为+，将运算结果压入栈中，栈中数据变成了 3 将 5 4 压入栈中，栈中数据变为了 3 5 4 遇到操作符+ 取出两个操作数5 4 运算结果为9，压入栈中，栈中变为3 9 遇到操作符$\times$ 取出3 9 运算结果为27 一个并不完善的简单过程 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//本程序仅支持0-9的数字运算int top,stack[1000];void push(int x)&#123; stack[++top]=x;&#125;int pop()&#123; return stack[top--];&#125;int main()&#123; char s[1000]; int i,a,b; i=0; top=0; scanf("%s",s); while(s[i]!='\0')&#123; if(s[i]=='+')&#123; a=pop(); b=pop(); push(a+b); &#125;else if(s[i]=='-')&#123; a=pop(); b=pop(); push(a-b); &#125;else if(s[i]=='*')&#123; a=pop(); b=pop(); push(a*b); &#125;else if(s[i]=='/')&#123;//整除结果 a=pop(); b=pop(); push(a/b); &#125;else &#123; push(s[i]-48); &#125; i++; &#125; printf("%d",pop()); return 0;&#125; 运行结果： 队列12345678910111213141516171819202122232425262728293031323334353637383940现有名称为namei且处理时间为timei的n个任务按照顺序排成一列，CPU通过循环调度法逐一处理这些任务，每个任务最多处理q ms(这个时间称为时间片)。如果q ms之后任务尚未处理完毕，那么该任务将被移动至队伍最末尾，CPU随即开始处理下一个任务 举个例子，假设q是100，然后有如下任务队列。 A(150) -- B(80) -- C(200) -- D(200) 首先A被处理100 ms，然后带着剩余的50 ms移动至队尾 B(80) -- C(200) -- D(200) -- A(50) 随后B被处理80 ms，在总计第180 ms时完成处理，从队列中消失 C(200) -- D(200) -- A(50) 接下来C被处理100 ms，然后带着剩余的100 ms移动至队尾。 D(200) -- A(50) -- C(100) 之后同理，一直循环到处理完所有任务。 请编写一个程序，模拟循环调度法。输入 输入形式如下 n q name1 time1 name2 time2 ... namen timen 第一行输入表示任务数的整数n与时间片的整数q，用一个空格隔开 接下来n行输入各任务的信息。字符串namei与timei用一个空格隔开。输出 按照任务完成的先后顺序输出各任务名以及结束时间，任务名与对应结束时间用空格隔开， 每一对任务名与结束时间占一行。限制 1 ≤n ≤100 000 1 ≤q ≤1000 1 ≤timei ≤50 000 1 ≤字符串namei的长度 ≤10 1 ≤timei的和 ≤1 000 000 输入示例 输出示例 5 100 p2 180 p1 150 p5 400 p2 80 p1 450 p3 200 p3 350 p4 350 p4 800 p5 20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;/* 以数组实验队列 */#define MAX 100005long tail ,head ; //头尾元素位置typedef struct queue&#123; char name[10]; long time;&#125;q;q Q[MAX];int isEmpty()&#123; if(tail==head) return 1; return 0;&#125;int isFull()&#123; if (tail+1==head) return 1; return 0;&#125;void enqueue(q p)&#123; if(!isFull())&#123; Q[tail]=p; tail=(tail+1)%MAX; &#125;&#125;q dequeue()&#123; q p; if(!isEmpty())&#123; p=Q[head]; head=(head+1)%MAX; &#125; return p;&#125;int main()&#123; tail=head=0; long elaps=0; int i=0; q u; long n,qtime; scanf("%ld %ld",&amp;n,&amp;qtime); while(i&lt;n)&#123; scanf("%s %ld",u.name,&amp;u.time); enqueue(u); i++; &#125; while(!isEmpty())&#123; u=dequeue(); if (u.time-qtime&lt;=0) &#123; elaps+=u.time; printf("%s %ld\n",u.name,elaps); continue; &#125; elaps+=qtime; u.time-=qtime; enqueue(u); &#125;&#125; 运行结果: STL(C++标准库)C++库以提供“模板”为主，是指不必预先制定类型的函数或类。 STL为用户提供了多种名为辅容器（Container）的类，用于管理数据集合。在创建动态数组、表、栈、队列等结构时，只需要定义对应的容器。然后就可以通过调用成员函数或方法使用。 stack 函数名 功能 复杂度 size() 返回栈的元素数 O(1) top() 返回栈顶元素 O(1) pop() 从栈中取出并删除元素 O(1) push(x) 向栈中添加元素x O(1) empty() 当栈为空时返回true O(1) 1234567891011121314151617#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; S; S.push(1); S.push(2); S.push(3); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl; S.pop(); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl;&#125; 运行结果： 通过栈模板实现逆波兰表示 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int i=0,a,b; string s; stack&lt;int&gt; stk; cin&gt;&gt;s; while (s[i]!='\0') &#123; switch(s[i])&#123; case '+': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a+b); break; case '-': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a-b); break; case '*': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a*b); break; default: stk.push(s[i]-48); &#125; i++; &#125; cout&lt;&lt;stk.top()&lt;&lt;endl; return 0;&#125; 运行结果： queue 函数名 功能 复杂度 size() 返回队列中的元素数目 O(1) front() 返回队头的元素 O(1) pop() 从队列中取出并删除元素 O(1) push(x) 在队列中添加元素x O(1) empty() 当队列为空时返回true O(1) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;string&gt; que; que.push("red"); que.push("yellow"); que.push("yellow"); que.push("blue"); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); return 0;&#125; 运行结果： 用标准库模板实现上面的队列 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;pair&lt;string,int&gt;&gt; que; string name; int n,q,t; int elaps=0; cin&gt;&gt;n&gt;&gt;q; while(n--)&#123; cin&gt;&gt;name&gt;&gt;t; que.push(make_pair(name,t)); &#125; pair&lt;string,int&gt; u; while(!que.empty()) &#123; u=que.front(); que.pop(); if(u.second-q&lt;=0)&#123; elaps+=u.second; cout&lt;&lt;u.first&lt;&lt;' '&lt;&lt;elaps&lt;&lt;endl; continue; &#125; u.second-=q; elaps+=q; que.push(u); &#125; return 0;&#125; 运行结果： pair是保存对数值的结构体模板，声明时需要在&lt;&gt;中指令两个数据结构。make_pair用于生成一对数值，第一个元素通过first访问，第二个通过second访问 vector可以在添加元素是增加长度的数组成为动态数组或可变长数组。相对地，必须事先指定长度的是静态数组 STL中的vector（向量）实现了动态数组 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) pop_back() 删除向量的最后一个元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(n) erase(p) 删除向量中迭代器p指向的元素 O(n) clear() 删除向量中所有元素 O(n) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;void output(vector&lt;double&gt; v)&#123; for (int i = 0; i &lt; v.size(); i++) &#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;int main()&#123; vector&lt;double&gt; vec; vec.push_back(0.1); vec.push_back(0.2); vec.push_back(0.3); vec[2]=0.4; output(vec); vec.insert(vec.begin()+2,0.8); output(vec); vec.erase(vec.begin()+1); output(vec); return 0;&#125; 输出结果： listlist是一个双向列表 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) push_front(x) 在向量的开头添加x O(1) pop_back() 删除向量的最后一个元素 O(1) pop_front() 删除向量的开头元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(1) erase(p) 删除向量中迭代器p指向的元素 O(1) clear() 删除向量中所有元素 O(n) 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;int main()&#123; list&lt;char&gt; li; li.push_back('b'); //[b] li.push_front('a'); //[ab] li.push_back('c'); //[abc] cout&lt;&lt;li.front(); //a cout&lt;&lt;li.back(); //c li.pop_front(); //[bc] li.push_back('d'); //[bcd] cout&lt;&lt;li.front(); //b cout&lt;&lt;li.back(); //d return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记1]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[基础篇基础概念复杂性评估 时间复杂度：评估执行程序所需要的时间。可以估算出程序对计算机处理器的使用程序 空间复杂度：评估执行程序 所需的存储空间。可以估算出程序 对计算机内存的使用程度 “复杂度”大多数情况下是指的时间复杂度 大O表示法：大O表示法是一种评估算法效率的“标尺”，以诸如$O(n)$、$ O(n^2)$的形式表示算法的效率，其中n为问题的数据大小。 常用的复杂度比较 $ n $ $ log(n) $ $ \sqrt n$ $ nlog(n) $ $ n^2 $ $ 2^n $ $ n! $ 5 2 2 10 25 32 120 10 3 3 30 100 1024 3628800 20 4 4 80 400 1048576 约$ 2.4 \times 10^{18}$ 50 5 7 250 2500 约$ 10^{15}$ 约$ 3 \times 10^{64}$ 100 6 10 600 10000 约$ 10^{30}$ 约$ 9.3\times 10^{157}$ 1000 9 31 9000 $ 10^6$ 约$ 10^{300}$ 约$ 4 \times 10^{2567}$ $10^4$ 13 100 $ 1.3\times 10^{5}$ $ 10^9$ 约$ 10^{3000}$ 约$ 10^{35660}$ $10^5$ 16 316 $ 1.6 \times 10^{6}$ $ 10^{10}$ 约$ 10^{30000}$ 约$ 10^{456574}$ $ 10^6$ 19 100 $ 1.9 \times 10^{7}$ $ 10^{12}$ 约$ 10^{300000}$ 约$ 10^{5565709}$ 稳定排序是指在出现多次相同数据时，能保证稳定输出的排序算法 初等排序 排序 最好 最坏 稳定情况 插入排序 N（有序） $O(N^2)$ 稳定 冒泡排序 $O(N)$ $O(N^2)$ 稳定 选择排序 $O(N^2)$ $O(N^2)$ 不稳定 希尔排序 $O(N)$ $O(N^2)$ 不稳定 插入排序 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 1234567891011121314151617void InsertSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) &#123; int j=i-1; if(a[i]&lt;a[i-1])&#123; //若第i个元素小于第i-1个元素,移动有序序列插入------大于的话则直接插入 int swap=a[i]; //存储将要排序的元素 a[i]=a[i-1]; //向后移动一个元素 while(swap&lt;a[j])//查询将要插入的位置 &#123; a[j+1]=a[j]; j--; //元素后移 &#125; a[j+1]=swap;//循环结束 插入到指定位置 &#125; &#125;&#125; 冒泡排序 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213#include&lt;stdio.h&gt;void BuddleSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; for( int j=0;j&lt;n-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; int swap=a[j]; a[j]=a[j+1]; a[j+1]=swap; &#125; &#125; &#125;&#125; 选择排序步骤： 未排序序列中找到最小元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 以此类推，直到所有元素均排序完毕。 1234567891011121314151617181920void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; int min=i; //存放数组最小值的位置 for(int j=i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[min])&#123; min=j; //找出最小值，并记录位置 &#125; &#125; if(min!=i) //最小元素与第i个元素互换位置 &#123; int swap=a[min]; a[min]=a[i]; a[i]=swap; &#125; &#125;&#125; 希尔排序步骤： 选取间隔为g的元素进行插入排序 缩小g的范围，新的g与原g互质 重复执行步骤1，2 最后选取g=1执行一次插入排序 1234567891011121314151617insertionSort(A,n,g)&#123; for i = g to n-1 v=A[i] j=i-g while j&gt;=0 &amp;&amp; A[j]&gt;v A[j+g]=a[j] j=j-g cnt++ A[j+g]=v&#125;shellSort(A,n)&#123; cnt=0; m=?; g[]=&#123;……,1&#125;; for i=0 to m-1 insertionSort(A,n,g[i])&#125; 注： 最后一定要执行一次g=1的普通 插入排序 ，确保正确 参考教材：《挑战程序设计竞赛2 算法数据结构》 参考资料：https://www.cnblogs.com/xaimicom/p/9189471.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
