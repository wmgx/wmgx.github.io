<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我错了！kde还是很不错的]]></title>
    <url>%2F2019%2F08%2F12%2Fmanjarokde%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我的manjaro用的是dde的桌面，诚然，非常不错，真的非常不错，就是稍微，启动应用程序慢了点，让我真的有一丢丢的无奈。 无奈下我还是尝试了一下kde的manjaro，前面说过，kde，慢！慢！！慢！！！。 kde启动是真的很慢，但是进了桌面，加载完成之后，其实，感觉，还挺好的，包括各种动画啊啥的都设置好了，启动程序说实话比dde启动程序快的好多，而且动画我也很喜欢。 但是还是遇到了一些问题不知道怎么解决。 全局菜单有时有有时没有，因为先在移动硬盘中装过一个manjaro kde系统，配置运行之后，感觉非常不错，这个全局菜单应该是支持chrome，typora，VScode 等一系列软件的，但是不知道为什么，现在只支持系统原生的了，很奇怪 PicGo上传缓慢，在移动硬盘里面的系统运行时都是秒传的，这一点我也不知道为什么 eclipse报了一个冲突的错误，只要打开.java的文件就报错，没办法，我重装了一次系统。 附上我简单配置的桌面，虽然不好看……]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>kde</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记6——树形结构]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846%EF%BC%9A%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[结构树结构树结构是一种数据结构，由节点（node）以及链接节点的边构成（edge）]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记5——高等排序]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845%EF%BC%9A%E9%AB%98%E7%AD%89%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序过程有些复杂，先来张动图掩饰下尴尬。 过程 将给定的包含n个元素的局部数“分割”成两个局部数组，每个数组各包含$\frac{n}{2}$个元素。（Divide） 对连个局部数组分别执行 mergeSort(归并)排序。(Solve) 通过merge将连个已经排序完成的数组“整合”成一个数组。(Conquer) merge对于merge过程，可以利用已经排好序的前提条件，执行$O(n1+n2)$的算法进行整合。在左半部分（L）和右半部分（R）的末尾分别安插一个 大于所有元素的标记。在比较L、R的元素过程中，只要标记设计的足够大，切将比较次数控制在$n1+n2$($right-left$)之内，就可以防止两个标记相比较。 mergeSortmergeSort 过程中，如果局部数组只剩下一个元素时，mergeSort不做任何处理直接结束。如果不是，则计算局部数组的中央位置mid，将left到mid (不包含) 视作前半部分，mid到right(不包含)视作后半部分。递归套用mergeSort 过程实现流程 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;#define MAX 50000#define SENTINEL 2000000000int L[MAX/2+2],R[MAX/2+2];int cnt;void merge(int A[],int left,int mid,int right)&#123; int n1 = mid - left; //左边的元素数目 int n2 = right -mid; //右边的元素数目 for (int i = 0; i &lt; n1; i++) L[i]=A[left+i]; for (int i = 0; i &lt; n2; i++) R[i]=A[mid+i]; L[n1]=R[n2]=SENTINEL; //设置最大值标志 int i=0,j=0; for(int k=left;k&lt;right;k++)&#123; cnt++; A[k]= L[i]&lt;=R[j]? L[i++]: R[j++]; &#125;&#125;void mergeSort(int A[],int left,int right)&#123; if(left+1&lt;right)&#123; int mid=(left+right)/2; mergeSort(A,left,mid); mergeSort(A,mid,right); merge(A,left,mid,right); &#125;&#125;int main()&#123; int A[MAX],n,i; cnt=0; cin&gt;&gt;n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;A[i]; &#125; mergeSort(A,0,n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;A[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl&lt;&lt;cnt&lt;&lt;endl; return 0; &#125; 运行结果 一共执行34次就完成了排序 快速排序快速排序利用基准值将数组分为两个部分，比基准值小的在基准值前面，比基准值大的在基准值后面。如果基 过程 以整个数组为对象执行quickSort qurickSort过程: 讲数组分割成前后两个局部数组 对前半部分执行quickSort 对后半部分执行quickSort 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define Max 100000#define SENTINEL 2000000000int cnt;int L[Max/2+2],R[Max/2+2];int partition(int A[],int p,int r)&#123; int i,j; int t,x; x=A[r]; i=p-1; for(j=p;j&lt;r;j++)&#123; if(A[j]&lt;x)&#123; cnt++; i++; t=A[i]; A[i]=A[j]; A[j]=t; &#125; &#125; t=A[i+1]; A[i+1]=A[r]; A[r]=t; return i+1;&#125;void quickSort(int A[],int p,int r)&#123; int q; if(p&lt;r)&#123; q=partition(A,p,r); quickSort(A,p,q-1); quickSort(A,q+1,r); &#125;&#125;int main()&#123; int n,i,v; int A[Max]; cnt=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; quickSort(A,0,n-1); for(i=0;i&lt;n;i++)&#123; printf("%d ",A[i]); &#125; printf("\n%d",cnt); return 0;&#125; 如果中间值选的好的话次数大大减少，在上面的同等情况下，快排仅需要20次。 利用标准库排序sortsort的第一个参数制定排序对象开头的迭代器，第二个参数制定末尾的迭代器(排序对象不包含末尾)，对于数组要代入指针。 STL的sort基于快排实现，并且添加了对于最坏情况的应对机制，但是 sort 属于不稳定排序算法 可以用stable_sort 基于归并排序的算法，但是耗费空间大一点，速度稍慢 sort向量代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; vector&lt;int&gt; v; cin &gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; v.push_back(x); &#125; sort(v.begin(),v.end()); for(int i=0;i&lt;v.size();i++)&#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; sort 数组排序123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; int a[100000]; cin &gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; https://images2018.cnblogs.com/blog/941490/201805/941490-20180514224313332-798344959.png https://www.cnblogs.com/onepixel/p/7674659.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro npm换源]]></title>
    <url>%2F2019%2F08%2F06%2Fnpm%E6%8D%A2%E6%BA%90%2F</url>
    <content type="text"><![CDATA[安装因为要用hexo，所以要安装 nodejs 和 npm 。 在manjaro下 安装十分方便 12sudo pacman -S nodejssudo pacman -S npm 换源npm默认源是国外，相当慢，所以要换成国内的 方法11npm config set registry https://registry.npm.taobao.org 可以通过这条命令验证 1npm config get registry 方法2安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 以后用npm的地方都可以用cnpm替换使用]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 VSCode c/c++环境配置]]></title>
    <url>%2F2019%2F08%2F03%2FVSCode%20c_c%2B%2B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[切换中文安装完成的VSCode是英文的，作为一个英文不好的中国人，我还是喜欢看中文的界面。 点击左侧的 会进入扩展商店 拓展商店中直接搜索Chinese 然后点击Install就行 安装完成后重启应用就会变成中文界面。 安装插件Code Runner 安装完成后窗口菜单栏下面就会出来一个 当你的显示页面是一个程序源文件（单个文件，不是项目）时，点击这个按钮或者按ctrl+F5就可以直接运行这个程序，方便快捷。 点击齿轮，点击配置，然后把右侧的Run In Terminal勾上，就会在控制台显示运行结果 c/c++必装的插件。 C++ IntellisenseC++的只能提示工具 C/C++ Clang Command Adapter提供静态检测（Lint） 配置环境主要是连个json文件 launch.json 点击调试，然后选择添加配置。会自动生成lanunch.json文件 这是我的配置，可以直接复制过去 要注意的就是 &quot;program&quot;: &quot;${workspaceFolder}/hello.out&quot;, //当前目录下编译后的可执行文件 "build"`1234567891011121314151617181920212223242526272829303132这里的hello.out应该是你生成的执行文件，而build 应该是你的tasks的lable```json&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;debug cpp&quot;, //名称 &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/hello.out&quot;, //当前目录下编译后的可执行文件 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, //表示当前目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: false, // 在vscode自带的终端中运行，不打开外部终端 &quot;MIMode&quot;: &quot;gdb&quot;, //用gdb来debug &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;build&quot; //执行lanuch之前运行的task &#125; ]&#125; tasks.json按住ctrl+shift+p 输入tasks，选择configure Task 选择使用模板创建然后选others 就会生成tasks.json文件 仍旧可以直接拷贝 参数应该是自己的，多个文件编译，和在bash中写一样，也可以用makefile 1234567891011121314151617&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "build", // task的名字 "type": "shell", "command": "g++", //编译命令 "args": [ //编译参数列表 "hello.cpp", "-o", "hello.out" ] &#125; ]&#125; c_cpp_properties.json ctrl+shift+p 输入c/c++:Edit Configurations 选择这一项就可以创建一个c_cpp_properties.json文件 不用改动，我也贴出来我的配置 12345678910111213141516&#123; "configurations": [ &#123; "name": "Linux", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [], "compilerPath": "/usr/bin/gcc", "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "gcc-x64" &#125; ], "version": 4&#125; 如果有自己的外链库也是添加到这里面。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>VScode</tag>
        <tag>程序安装</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro kde 更换 dde 桌面]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjarokde%E6%9B%B4%E6%8D%A2dde%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[当我配置完成一切，各种工具，各种精美的动画效果，炫酷的特效。准备写博客的时候，发现复制到剪贴板中的图片，没有！没有！还是没有！ 上网一查，发现是kde中自带的剪贴板不能保存图片(里面有个设置，不保存图片，我关闭了，还是不行)，无奈下，网上有人说换剪贴板。但是我实在是不会换。 没办法舍弃了一切，放弃kde 安装dde，转了一圈又回来了。（安装deepin的桌面，不是deepin的系统） 1. 下载dde1pacman -S deepin deepin-extra 2.修改配置文件将/etc/lightdm/lightdm.conf中的选项greeter-session设置为lightdm-deepin-greeter 默认是注释掉的，将前面的#删除即可 3.禁用sddm（kde）1systemctl disable sddm 4.启用lightdm1systemctl enable lightdm 5.重启1reboot 6.卸载kde配套相关（可选）123pacman -Rsc plasmapacman -Rsc kde-applications 参考：https://www.jianshu.com/p/a1e31a9a50dc]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro，linux，踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro系统初始配置]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjaro%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[换源更新manjaro中的包管理命令是 pacman 一个十分出色的包管理工具，解决了其他linux 下的安装依赖问题。 常用命令 123pacman -S 软件名 #安装pacman -Syu #更新pacman -R 软件名 #移除 安装完系统，首要就是更新软件和系统，更新之前，要换源，换成中国的源 1sudo pacman-mirrors -i -c China -m rank 这条命令换源到中国，并按速度排序 执行完命令之后会弹出这样的对话框 选择快的，点OK就可以了。 更新一下源 1sudo pacman -Syy 然后更新系统 1sudo pacman -Syyu 个人喜欢vim，先安装一个vim后面要用到 1sudo pacman -S vim 添加archlinuxcn软件源（archlinuxcn是一个中国的软件源，包含了很多常用的中文软件和工具） 1sudo vim /etc/pacman.conf 在文件最下面添加 12[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 更新软件源并导入公钥 1sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 系统的初始配置就做好了 安装软件管理工具manjaro中带有图形管理工具，可以完成应用的安装，删除，检索等操作，我系统在现在是KDE的管理工具 个人感觉不如gonme中的好用，但是却不知道怎么更换，没办法了。 安装yaourt（有些东西pacman装不了）1sudo pacman -S yaourt 安装 chrome1sudo pacman -S google-chrome 安装截图工具1sudo pacman -S deepin-screenshot 安装QQ1sudo pacman -S deepin.com.qq.im 安装TIM(kde下不好装QQ，TIM还好)1sudo pacman -S deepin.com.qq.office 安装网易云音乐1sudo pacman -S netease-cloud-music 安装搜狗输入法123sudo pacman -S fcitx-imsudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyin 添加输入法配置文件 sudo vim ~/.xprofile 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx" 可以进行各种配置 配置完需要重启计算机 安装 markdown 编辑器不得不说比deepin安装得方便 1sudo yaourt typora 安装vscode1sudo pacman -S visual-studio-code-bin 安装eclipse1sudo pacman -S eclipse 安装WPS1sudo pacman -S ttf-wps-fonts 图床工具PicGo如果对图床工具有需要的话 直接到官网下载AppImage文件，双击就可以用了 到此为止，常用的软件都已经装上了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>系统配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro安装]]></title>
    <url>%2F2019%2F08%2F02%2Fmanjaro%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[制作启动盘安装系统,最先就要制作启动盘嘛. 推荐以 dd 模式写入(不分系统区与数据区) 在进入U盘的时候一定要bios的安全启动(Secure Boot) 关闭(Disabled)不然进不去系统. 安装系统然后就可以看到这个界面 如果你是双显卡的电脑，driver这里一定要设置为no-free，不然装好了之后，是黑屏。 进入系统后会出现这个界面。从左上角可以选择语言，点击 启动安装程序 就可以进入系统安装界面了 一步步设置下去。 如果像我一样，在移动硬盘中安装，一定要注意: 硬盘是GPT格式！！！ 硬盘是GPT格式！！！ 硬盘是GPT格式！！！ 不然这里没有你的移动硬盘出现（我为什么知道？我都被逼疯了我会不知道！？） 选择硬盘你可以自己选择挂载，也可直接全盘安装，都可以。然后就等待就可以了。 因后写的经历，当初没来得及截图，图片来源： https://cloud.tencent.com/developer/article/1390999 https://www.cnblogs.com/smlile-you-me/p/8830949.html https://zhidao.baidu.com/question/2144265946313985668.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>搞系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本机配置]]></title>
    <url>%2F2019%2F08%2F01%2Fgit%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置用户名和邮箱12git config --global user.name yourUserNamegit config --global user.email yourEmail@email 生成SSH秘钥1ssh-keygen -t rsa -C "YourEmail" #注意引号 会在用户的目录下生成一个.ssh的文件夹 文件夹里面有两个文件，一个公钥一个私钥，需要讲公钥放到 github里面，才可以用本机访问github上自己的文件 将秘钥复制到github 这就是秘钥 登录github在 左侧一列中选择 然后点击 复制进来刚才的秘钥就可以了 验证输入命令 1ssh -T git@github.com 中间会问你一次，回答yes就行， 如果提示最后一行，就说明你成功了！！！ 如果提示 12sign_and_send_pubkey: signing failed: agent refused operationPermission denied (publickey). 请查看博客 git 配置后 ssh -T git@github.com出错]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro linux 安装总结]]></title>
    <url>%2F2019%2F08%2F01%2Fmanjaro%20linux%20%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[折腾了好几天，从deepin 到 manjaro 折腾好几天终于可以说是勉强弄好了（搞累了，不想搞了） 没有前面的可能没有任何截图 deepindeepin 一开始再B站上看见了他的UI ，感觉挺漂亮，就往打算装了移动硬盘里。 因为不喜欢开机选择系统，也不想放弃windows , 第一次往移动硬盘里面装，不知道会不会把引导写进我的系统里面，我就把电脑本身的两个硬盘都拆卸了下来（原谅我的怂）。 装好之后，确实很漂亮，也让我很喜欢，但是最新版本中极力吹鼓的云同步功能却说我不在他们的服务范围内（WTF！？）虚拟机里还能用，一番百度，看论坛，也没有看到解决办法，还好，云同步并不是那么重要暂时，不要就不要吧。 一番操作猛如虎，终于完成了基础工作的配置，下面的dock非常不错，但是没有mac中的特效， 这个启动器也是非常不错的体验 好吧，，，这个截图是我现在系统的截图，manjao用的dde的桌面…… deepin 我一共装了两回，崩了两次。 第一次是更新系统 ，好吧，是我等不及，他一直更新不完我就重启了，然后就进不了系统界面了，输入密码之后是黑屏……无奈重装，可怜我一晚上的部署操作。 第二次是卸载软件，我应该是不太专业……不知道卸载了什么，反正突然系统自带的应用丢了一大部分，深度应用商店，深度截图，深度……都没了。 这一次装的时候，懒得拆硬盘了，直接选中移动硬盘，全盘安装，很幸运，引导卸载了移动硬盘中。 无奈下，弃坑，转投manjaro manjaromanjaro 说实话，在用之前我真不知道还有这么个系统，之前听别人提到的时候我以为是和docker类似的什么环境。 manjaro采用滚动式升级，升级系统不用重装，也可以回滚，个人感觉很不错 manjaro 几乎涵盖了所有主流的桌面系统，gonme，kde，dde等等 第一次安装了一个自带gonme的manjaro，个人感觉还是很不错的，但是在本人手残的一系列操作下，gonme还是崩溃了，至少我不知道怎么把他变回原样了，我选择重装 重装了一个kde的桌面，第一次进系统，不得不说，真的…… ………… 好慢啊………… ………… 但是kde的ui是真的漂亮，仿mac做的很好，各种窗口的动画我也非常喜欢。 但是很受不了的是，kde自带的剪贴板存不了图片,这真的很让人头疼，我想到了换剪贴板，但是多方查阅资料后，我发现，还是不会换。 无奈下我选择了重装桌面，只重装桌面，安装dde（没错，就是深度）然后将kde卸载。 但是回到dde后发现，，，，kde的动画真好看，dde的ui虽然不错但是kde动画真好看 对了 kde 对于qq好像不是很支持，安装qq的时候安装的很费劲。 这就是我现在的桌面了 经过了长达两三天，无数次的重装，终于得到了一个稍微满意的系统。 中间猜的坑，会单独做总结。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
        <tag>linux</tag>
        <tag>踩坑经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin linux 下安装Typora]]></title>
    <url>%2F2019%2F07%2F29%2Fdeepin%20linux%20%E4%B8%8B%E5%AE%89%E8%A3%85Typora%2F</url>
    <content type="text"><![CDATA[一直喜欢Typora，刚刚装了deepin Linux ，打算安装一下，但是照着官网给出的教程，却总是报错 123456sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora 这是官网给出的教程，但是在第一步就报错，报了两个文件缺失的错误，当时没有截下图来。 之后执行 1sudo apt-get install dirmngr 就可以了 但是在执行第二行的时候也报错，这里有两个解决办法 1sudo add-apt-repository 'deb https://typora.io/linux ./‘ 方法一： 1sudo vim /etc/apt/sources.list 然后手动添加sudo add-apt-repository ‘deb https://typora.io/linux ./”（不带双引号） 方法二：需要安装 12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 但是 依赖有问题 1sudo aptitude install python-software-properties 同理 1sudo aptitude install software-properties-common 然后运行 123sudo add-apt-repository ‘deb https://typora.io/linux ./’ sudo apt-get update sudo apt-get install typora 就可以完成安装 执行 1typora 就可以运行了]]></content>
      <categories>
        <category>程序安装</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git添加公钥后报错sign_and_send_pubkey]]></title>
    <url>%2F2019%2F07%2F28%2Fgit%E6%B7%BB%E5%8A%A0%E5%85%AC%E9%92%A5%E5%90%8E%E6%8A%A5%E9%94%99sign_and_send_pubkey%20signing%20failed%2F</url>
    <content type="text"><![CDATA[错误描述当在github上添加公钥之后运行ssh -T git@github.com 提示错误： 12sign_and_send_pubkey: signing failed: agent refused operationPermission denied (publickey). 解决办法12eval "$(ssh-agent -s)"ssh-add]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>程序安装</tag>
        <tag>经验</tag>
        <tag>git</tag>
        <tag>错误解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构-笔记4-递归与分治]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B04-%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[递归递归是指自己调用自己的函数。 如下面的阶乘递归 12345fact(int n)&#123; if(n==1) return n; return fact(n-1)*n;&#125; 递归函数必须要设置出口，也就是上面的 12if(n==1) return n; 分治分治的过程 将问题分割成局部问题(Divide) 递归地求解局部问题(Solve) 将局部问题的解整合成原问题的解(Conquer) 搜索： 1234567891011findMax(int A[],l,r)&#123; int m; int u,v; m=(l+r)/2; if(l==r-1)&#123; return A[l] &#125;else&#123; u=findMax(A,l,m) &#125; &#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记3——搜索]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B03-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[概述搜索是从数据集合中找出目标元素的处理。 graph LR A{搜索} -->B(线性搜索) A--> C(二分搜索) A--> E(散列) 线性搜索线性搜索是从数组开头顺次访问个元素，检查给该元素是否与目标值相等。相等则返回元素位置并结束搜索。如果检查完数组还没有发现目标值，则返回一个特殊值来说明。线性搜索的算法效率很低，但适用于任何形式的数据。 二分搜索二分搜索算法可以利用数据的大小进行高速搜索。二分搜索的前提是 已经排序。 思路： 将整个数组（升序）作为搜索范围 检查位于搜索范围正中央的元素 如果一致则结束 如果不一致则比较大小，小于的话，以前半部分为搜索范围执行第二步。否则以后半部分为范围执行。 如果到最后没找到，就返回特定值，表示未找到 散列法在散列法中，各元素的存储位置由散列函数决定。散列既是一种数据结构，同时也是一种使用散列表的算法。只需要将关键字（key）带入就可得到对应位置。搜索效率很高。 线性搜索题目请编写一个程序，输入包含 n 个整数的数列 s 以及包含 q 个不重复整数数列 T ，输出既包含于 T 又包含于 S 的整数个数 c 输入： 第一行输入 n，第二行输入代表 S 的 n 个整数，第三行输入 q，第四行输入代表 T 的 q 个整数。 输出：用1行输出C 限制： $n\leq1000$，$q\leq500$ ，$0\leq{S,T的元素}\leq{10^9}$，T中元素不重复 输入示例: 123451 2 3 4 533 4 1 输出示例： 13 程序123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int i=0; A[n]=key;//通过将最后一个置为key的方法，引入标记，可以提升效率，在处理大数据的时候会有显著效果 while(A[i]!=key) i++; return i!=n;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 输出结果 因为线性搜索的算法复杂度为$O(n)$，所以算法的复杂度$O(qn)$ 二分搜索对于含有 n 个元素的素组执行线性搜索以及二分搜索时，最坏的情况下运算次数如下 元素数 线性搜索 二分搜索 100 100 7 10000 10000 14 1000000 1000000 20 最坏情况下二分搜索的复杂度大概是$log_2n$ 题目同上题，假设输入有序数列 程序123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int search(int A[],int n, int key)&#123; int left=0; int right=n-1; int mid; while(left&lt;right)&#123; mid=(left+right)/2; if(key==A[mid]) return 1; if(key&gt;A[mid])left=mid+1; else right=mid-1; &#125; return 0;&#125;int main()&#123; int i,n,A[10001],q,key,sum=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;A[i]); &#125; scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d",&amp;key); if (search(A,n,key)) &#123; sum++; &#125; &#125; printf("%d\n",sum); return 0;&#125; 运行结果： 散列法不同于数组的下标索引，可以通过键值直接查到对应值，每一个键值都有一个唯一对应的值 数组索引 a[0],a[1],a[2]…… 散列 a[key0],a[key1],a[key2]…… 方法： 通过散列函数在键值与值之间建立一个对应的函数关系Hash() 存储位置可以通过 address=Hash(key) 的方式运算出来 在插入和搜索时通过步骤2的方式可以迅速得出键值对应值的存储位置 散列函数方法中步骤1中所涉及的函数关系叫做散列函数 散列函数在使用的时候应该注意： 简单，快速的可以计算出结果 在双散列结构中，当多个键值的散列值相同时，即冲突发生时，可以调用hash1() hash2() hash3()……等一系列散列函数得到不同的散列值 STL迭代器迭代器是一种对象，可以对容器中对象进行迭代处理，指向容器中的位置 可以使用的运算符 运算符 效果 ++ 指向下一个迭代器 ==，!= 判断两个迭代器指向位置是否相等 = 将运算符右侧迭代器赋值给左侧迭代器 * 返回该位置元素 容器函数 函数名 效果 begin() 返回容器的开头元素 end() 返回容器的最后一个元素 1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; int i; for(i=0;i&lt;10;i++)&#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator iter; for(iter=v.begin();iter!=v.end();iter++)&#123; cout&lt;&lt;*iter&lt;&lt;" "; &#125;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记2——数据结构]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[概述栈(Stack)规则后入先出（Last In First Out,LIFO） 操作 push(X)：在栈的顶部压入元素X pop(): 从栈的顶部取出元素 isEmpty()：检查栈是否为空 isFull(): 检查栈是否已满 一般情况下，栈还具有 “引用栈顶元素”和”检查栈中是否含有指定数据“的操作 队列(Queue)规则先入先出（First In First Out） 操作 enqueue(x)：在队列的末端添加元素x dequeue(): 从队列开头取出元素 isEmpty(): 检查队列是否为空 isFull()：检查队列是否已满 一般情况下，队列还具有 “引用队列第一个元素”和”检查队列中是否含有指定数据“的操作 应用逆波兰表示法(栈的应用)逆波兰表示法是一种将操作符写在操作数后面的方法，又叫后缀表示法，相较于我们日常使用的中缀表示法**，它的优势在于不需要括号 例：$（1+2）\times (5+4) $ ==&gt;&gt;$1\space 2 + 5\space 4 + \times $ 将 1 2 压入栈中 遇到运算符，从栈中取出两个操作数，按运算符运算，例中为+，将运算结果压入栈中，栈中数据变成了 3 将 5 4 压入栈中，栈中数据变为了 3 5 4 遇到操作符+ 取出两个操作数5 4 运算结果为9，压入栈中，栈中变为3 9 遇到操作符$\times$ 取出3 9 运算结果为27 一个并不完善的简单过程 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//本程序仅支持0-9的数字运算int top,stack[1000];void push(int x)&#123; stack[++top]=x;&#125;int pop()&#123; return stack[top--];&#125;int main()&#123; char s[1000]; int i,a,b; i=0; top=0; scanf("%s",s); while(s[i]!='\0')&#123; if(s[i]=='+')&#123; a=pop(); b=pop(); push(a+b); &#125;else if(s[i]=='-')&#123; a=pop(); b=pop(); push(a-b); &#125;else if(s[i]=='*')&#123; a=pop(); b=pop(); push(a*b); &#125;else if(s[i]=='/')&#123;//整除结果 a=pop(); b=pop(); push(a/b); &#125;else &#123; push(s[i]-48); &#125; i++; &#125; printf("%d",pop()); return 0;&#125; 运行结果： 队列12345678910111213141516171819202122232425262728293031323334353637383940现有名称为namei且处理时间为timei的n个任务按照顺序排成一列，CPU通过循环调度法逐一处理这些任务，每个任务最多处理q ms(这个时间称为时间片)。如果q ms之后任务尚未处理完毕，那么该任务将被移动至队伍最末尾，CPU随即开始处理下一个任务 举个例子，假设q是100，然后有如下任务队列。 A(150) -- B(80) -- C(200) -- D(200) 首先A被处理100 ms，然后带着剩余的50 ms移动至队尾 B(80) -- C(200) -- D(200) -- A(50) 随后B被处理80 ms，在总计第180 ms时完成处理，从队列中消失 C(200) -- D(200) -- A(50) 接下来C被处理100 ms，然后带着剩余的100 ms移动至队尾。 D(200) -- A(50) -- C(100) 之后同理，一直循环到处理完所有任务。 请编写一个程序，模拟循环调度法。输入 输入形式如下 n q name1 time1 name2 time2 ... namen timen 第一行输入表示任务数的整数n与时间片的整数q，用一个空格隔开 接下来n行输入各任务的信息。字符串namei与timei用一个空格隔开。输出 按照任务完成的先后顺序输出各任务名以及结束时间，任务名与对应结束时间用空格隔开， 每一对任务名与结束时间占一行。限制 1 ≤n ≤100 000 1 ≤q ≤1000 1 ≤timei ≤50 000 1 ≤字符串namei的长度 ≤10 1 ≤timei的和 ≤1 000 000 输入示例 输出示例 5 100 p2 180 p1 150 p5 400 p2 80 p1 450 p3 200 p3 350 p4 350 p4 800 p5 20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;/* 以数组实验队列 */#define MAX 100005long tail ,head ; //头尾元素位置typedef struct queue&#123; char name[10]; long time;&#125;q;q Q[MAX];int isEmpty()&#123; if(tail==head) return 1; return 0;&#125;int isFull()&#123; if (tail+1==head) return 1; return 0;&#125;void enqueue(q p)&#123; if(!isFull())&#123; Q[tail]=p; tail=(tail+1)%MAX; &#125;&#125;q dequeue()&#123; q p; if(!isEmpty())&#123; p=Q[head]; head=(head+1)%MAX; &#125; return p;&#125;int main()&#123; tail=head=0; long elaps=0; int i=0; q u; long n,qtime; scanf("%ld %ld",&amp;n,&amp;qtime); while(i&lt;n)&#123; scanf("%s %ld",u.name,&amp;u.time); enqueue(u); i++; &#125; while(!isEmpty())&#123; u=dequeue(); if (u.time-qtime&lt;=0) &#123; elaps+=u.time; printf("%s %ld\n",u.name,elaps); continue; &#125; elaps+=qtime; u.time-=qtime; enqueue(u); &#125;&#125; 运行结果: STL(C++标准库)C++库以提供“模板”为主，是指不必预先制定类型的函数或类。 STL为用户提供了多种名为辅容器（Container）的类，用于管理数据集合。在创建动态数组、表、栈、队列等结构时，只需要定义对应的容器。然后就可以通过调用成员函数或方法使用。 stack 函数名 功能 复杂度 size() 返回栈的元素数 O(1) top() 返回栈顶元素 O(1) pop() 从栈中取出并删除元素 O(1) push(x) 向栈中添加元素x O(1) empty() 当栈为空时返回true O(1) 1234567891011121314151617#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; S; S.push(1); S.push(2); S.push(3); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl; S.pop(); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl;&#125; 运行结果： 通过栈模板实现逆波兰表示 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int i=0,a,b; string s; stack&lt;int&gt; stk; cin&gt;&gt;s; while (s[i]!='\0') &#123; switch(s[i])&#123; case '+': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a+b); break; case '-': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a-b); break; case '*': a=stk.top();stk.pop(); b=stk.top();stk.pop(); stk.push(a*b); break; default: stk.push(s[i]-48); &#125; i++; &#125; cout&lt;&lt;stk.top()&lt;&lt;endl; return 0;&#125; 运行结果： queue 函数名 功能 复杂度 size() 返回队列中的元素数目 O(1) front() 返回队头的元素 O(1) pop() 从队列中取出并删除元素 O(1) push(x) 在队列中添加元素x O(1) empty() 当队列为空时返回true O(1) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;string&gt; que; que.push("red"); que.push("yellow"); que.push("yellow"); que.push("blue"); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); cout&lt;&lt;que.front()&lt;&lt;"\tnow size:"&lt;&lt;que.size()&lt;&lt;endl; que.pop(); return 0;&#125; 运行结果： 用标准库模板实现上面的队列 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;int main()&#123; queue&lt;pair&lt;string,int&gt;&gt; que; string name; int n,q,t; int elaps=0; cin&gt;&gt;n&gt;&gt;q; while(n--)&#123; cin&gt;&gt;name&gt;&gt;t; que.push(make_pair(name,t)); &#125; pair&lt;string,int&gt; u; while(!que.empty()) &#123; u=que.front(); que.pop(); if(u.second-q&lt;=0)&#123; elaps+=u.second; cout&lt;&lt;u.first&lt;&lt;' '&lt;&lt;elaps&lt;&lt;endl; continue; &#125; u.second-=q; elaps+=q; que.push(u); &#125; return 0;&#125; 运行结果： pair是保存对数值的结构体模板，声明时需要在&lt;&gt;中指令两个数据结构。make_pair用于生成一对数值，第一个元素通过first访问，第二个通过second访问 vector可以在添加元素是增加长度的数组成为动态数组或可变长数组。相对地，必须事先指定长度的是静态数组 STL中的vector（向量）实现了动态数组 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) pop_back() 删除向量的最后一个元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(n) erase(p) 删除向量中迭代器p指向的元素 O(n) clear() 删除向量中所有元素 O(n) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;void output(vector&lt;double&gt; v)&#123; for (int i = 0; i &lt; v.size(); i++) &#123; cout&lt;&lt;v[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl;&#125;int main()&#123; vector&lt;double&gt; vec; vec.push_back(0.1); vec.push_back(0.2); vec.push_back(0.3); vec[2]=0.4; output(vec); vec.insert(vec.begin()+2,0.8); output(vec); vec.erase(vec.begin()+1); output(vec); return 0;&#125; 输出结果： listlist是一个双向列表 函数名 功能 复杂度 size() 返回向量的元素数目 O(1) push_back(x) 在向量的末尾添加x O(1) push_front(x) 在向量的开头添加x O(1) pop_back() 删除向量的最后一个元素 O(1) pop_front() 删除向量的开头元素 O(1) begin() 返回指向向量开头的迭代器 O(1) end() 返回指向向量结尾的迭代器 O(1) insert(p,x) 在向量中迭代器p指向的位置插入x O(1) erase(p) 删除向量中迭代器p指向的元素 O(1) clear() 删除向量中所有元素 O(n) 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;list&gt;#include&lt;string&gt;using namespace std;int main()&#123; list&lt;char&gt; li; li.push_back('b'); //[b] li.push_front('a'); //[ab] li.push_back('c'); //[abc] cout&lt;&lt;li.front(); //a cout&lt;&lt;li.back(); //c li.pop_front(); //[bc] li.push_back('d'); //[bcd] cout&lt;&lt;li.front(); //b cout&lt;&lt;li.back(); //d return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记1]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[基础篇基础概念复杂性评估 时间复杂度：评估执行程序所需要的时间。可以估算出程序对计算机处理器的使用程序 空间复杂度：评估执行程序 所需的存储空间。可以估算出程序 对计算机内存的使用程度 “复杂度”大多数情况下是指的时间复杂度 大O表示法：大O表示法是一种评估算法效率的“标尺”，以诸如$O(n)$、$ O(n^2)$的形式表示算法的效率，其中n为问题的数据大小。 常用的复杂度比较 $ n $ $ log(n) $ $ \sqrt n$ $ nlog(n) $ $ n^2 $ $ 2^n $ $ n! $ 5 2 2 10 25 32 120 10 3 3 30 100 1024 3628800 20 4 4 80 400 1048576 约$ 2.4 \times 10^{18}$ 50 5 7 250 2500 约$ 10^{15}$ 约$ 3 \times 10^{64}$ 100 6 10 600 10000 约$ 10^{30}$ 约$ 9.3\times 10^{157}$ 1000 9 31 9000 $ 10^6$ 约$ 10^{300}$ 约$ 4 \times 10^{2567}$ $10^4$ 13 100 $ 1.3\times 10^{5}$ $ 10^9$ 约$ 10^{3000}$ 约$ 10^{35660}$ $10^5$ 16 316 $ 1.6 \times 10^{6}$ $ 10^{10}$ 约$ 10^{30000}$ 约$ 10^{456574}$ $ 10^6$ 19 100 $ 1.9 \times 10^{7}$ $ 10^{12}$ 约$ 10^{300000}$ 约$ 10^{5565709}$ 稳定排序是指在出现多次相同数据时，能保证稳定输出的排序算法 初等排序 排序 最好 最坏 稳定情况 插入排序 N（有序） $O(N^2)$ 稳定 冒泡排序 $O(N)$ $O(N^2)$ 稳定 选择排序 $O(N^2)$ $O(N^2)$ 不稳定 希尔排序 $O(N)$ $O(N^2)$ 不稳定 插入排序 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 1234567891011121314151617void InsertSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) &#123; int j=i-1; if(a[i]&lt;a[i-1])&#123; //若第i个元素小于第i-1个元素,移动有序序列插入------大于的话则直接插入 int swap=a[i]; //存储将要排序的元素 a[i]=a[i-1]; //向后移动一个元素 while(swap&lt;a[j])//查询将要插入的位置 &#123; a[j+1]=a[j]; j--; //元素后移 &#125; a[j+1]=swap;//循环结束 插入到指定位置 &#125; &#125;&#125; 冒泡排序 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213#include&lt;stdio.h&gt;void BuddleSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; for( int j=0;j&lt;n-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; int swap=a[j]; a[j]=a[j+1]; a[j+1]=swap; &#125; &#125; &#125;&#125; 选择排序步骤： 未排序序列中找到最小元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 以此类推，直到所有元素均排序完毕。 1234567891011121314151617181920void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; int min=i; //存放数组最小值的位置 for(int j=i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[min])&#123; min=j; //找出最小值，并记录位置 &#125; &#125; if(min!=i) //最小元素与第i个元素互换位置 &#123; int swap=a[min]; a[min]=a[i]; a[i]=swap; &#125; &#125;&#125; 希尔排序步骤： 选取间隔为g的元素进行插入排序 缩小g的范围，新的g与原g互质 重复执行步骤1，2 最后选取g=1执行一次插入排序 1234567891011121314151617insertionSort(A,n,g)&#123; for i = g to n-1 v=A[i] j=i-g while j&gt;=0 &amp;&amp; A[j]&gt;v A[j+g]=a[j] j=j-g cnt++ A[j+g]=v&#125;shellSort(A,n)&#123; cnt=0; m=?; g[]=&#123;……,1&#125;; for i=0 to m-1 insertionSort(A,n,g[i])&#125; 注： 最后一定要执行一次g=1的普通 插入排序 ，确保正确 参考教材：《挑战程序设计竞赛2 算法数据结构》 参考资料：https://www.cnblogs.com/xaimicom/p/9189471.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
