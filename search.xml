<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记2——数据结构]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[概述栈(Stack)规则==后入先出==（Last In First Out,LIFO） 操作 push(X)：在栈的顶部压入元素X pop(): 从栈的顶部取出元素 isEmpty()：检查栈是否为空 isFull(): 检查栈是否已满 一般情况下，栈还具有 “引用栈顶元素”和”检查栈中是否含有指定数据“的操作 队列(Queue)规则==先入先出==（First In First Out） 操作 enqueue(x)：在队列的末端添加元素x dequeue(): 从队列开头取出元素 isEmpty(): 检查队列是否为空 isFull()：检查队列是否已满 一般情况下，队列还具有 “引用队列第一个元素”和”检查队列中是否含有指定数据“的操作 应用逆波兰表示法(栈的应用)逆波兰表示法是一种将操作符写在操作数后面的方法，又叫==后缀表示法==，相较于我们日常使用的中缀表示法，它的优势在于不需要括号 例：$（1+2）\times (5+4) $ ==&gt;&gt;$1\space 2 + 5\space 4 + \times $ 将 1 2 压入栈中 遇到运算符，从栈中取出两个操作数，按运算符运算，例中为+，将运算结果压入栈中，栈中数据变成了 3 将 5 4 压入栈中，栈中数据变为了 3 5 4 遇到操作符+ 取出两个操作数5 4 运算结果为9，压入栈中，栈中变为3 9 遇到操作符$\times$ 取出3 9 运算结果为27 一个并不完善的简单过程 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//本程序仅支持0-9的数字运算int top,stack[1000];void push(int x)&#123; stack[++top]=x;&#125;int pop()&#123; return stack[top--];&#125;int main()&#123; char s[1000]; int i,a,b; i=0; top=0; scanf("%s",s); while(s[i]!='\0')&#123; if(s[i]=='+')&#123; a=pop(); b=pop(); push(a+b); &#125;else if(s[i]=='-')&#123; a=pop(); b=pop(); push(a-b); &#125;else if(s[i]=='*')&#123; a=pop(); b=pop(); push(a*b); &#125;else if(s[i]=='/')&#123;//整除结果 a=pop(); b=pop(); push(a/b); &#125;else &#123; push(s[i]-48); &#125; i++; &#125; printf("%d",pop()); return 0;&#125; 运行结果： 队列12345678910111213141516171819202122232425262728293031323334353637383940现有名称为namei且处理时间为timei的n个任务按照顺序排成一列，CPU通过循环调度法逐一处理这些任务，每个任务最多处理q ms(这个时间称为时间片)。如果q ms之后任务尚未处理完毕，那么该任务将被移动至队伍最末尾，CPU随即开始处理下一个任务 举个例子，假设q是100，然后有如下任务队列。 A(150) -- B(80) -- C(200) -- D(200) 首先A被处理100 ms，然后带着剩余的50 ms移动至队尾 B(80) -- C(200) -- D(200) -- A(50) 随后B被处理80 ms，在总计第180 ms时完成处理，从队列中消失 C(200) -- D(200) -- A(50) 接下来C被处理100 ms，然后带着剩余的100 ms移动至队尾。 D(200) -- A(50) -- C(100) 之后同理，一直循环到处理完所有任务。 请编写一个程序，模拟循环调度法。输入 输入形式如下 n q name1 time1 name2 time2 ... namen timen 第一行输入表示任务数的整数n与时间片的整数q，用一个空格隔开 接下来n行输入各任务的信息。字符串namei与timei用一个空格隔开。输出 按照任务完成的先后顺序输出各任务名以及结束时间，任务名与对应结束时间用空格隔开， 每一对任务名与结束时间占一行。限制 1 ≤n ≤100 000 1 ≤q ≤1000 1 ≤timei ≤50 000 1 ≤字符串namei的长度 ≤10 1 ≤timei的和 ≤1 000 000 输入示例 输出示例 5 100 p2 180 p1 150 p5 400 p2 80 p1 450 p3 200 p3 350 p4 350 p4 800 p5 20 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;/* 以数组实验队列 */#define MAX 100005long tail ,head ; //头尾元素位置typedef struct queue&#123; char name[10]; long time;&#125;q;q Q[MAX];int isEmpty()&#123; if(tail==head) return 1; return 0;&#125;int isFull()&#123; if (tail+1==head) return 1; return 0;&#125;void enqueue(q p)&#123; if(!isFull())&#123; Q[tail]=p; tail=(tail+1)%MAX; &#125;&#125;q dequeue()&#123; q p; if(!isEmpty())&#123; p=Q[head]; head=(head+1)%MAX; &#125; return p;&#125;int main()&#123; tail=head=0; long elaps=0; int i=0; q u; long n,qtime; scanf("%ld %ld",&amp;n,&amp;qtime); while(i&lt;n)&#123; scanf("%s %ld",u.name,&amp;u.time); enqueue(u); i++; &#125; while(!isEmpty())&#123; u=dequeue(); if (u.time-qtime&lt;=0) &#123; elaps+=u.time; printf("%s %ld\n",u.name,elaps); continue; &#125; elaps+=qtime; u.time-=qtime; enqueue(u); &#125;&#125; 运行结果: STL(C++标准库)C++库以提供“模板”为主，是指不必预先制定类型的函数或类。 STL为用户提供了多种名为辅容器（Container）的类，用于管理数据集合。在创建动态数组、表、栈、队列等结构时，只需要定义对应的容器。然后就可以通过调用成员函数或方法使用。 stack 函数名 功能 复杂度 size() 返回栈的元素数 O(1) top() 返回栈顶元素 O(1) pop() 从栈中取出并删除元素 O(1) push(x) 向栈中添加元素x O(1) empty() 当栈为空时返回true O(1) 1234567891011121314151617#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; S; S.push(1); S.push(2); S.push(3); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl; S.pop(); cout&lt;&lt;"栈的大小："&lt;&lt;S.size()&lt;&lt;endl; cout&lt;&lt;"栈顶元素："&lt;&lt;S.top()&lt;&lt;endl;&#125; 运行结果：]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法 程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计：算法和数据结构 笔记1]]></title>
    <url>%2F2019%2F07%2F09%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[基础篇基础概念复杂性评估 时间复杂度：评估执行程序所需要的时间。可以估算出程序对计算机处理器的使用程序 空间复杂度：评估执行程序 所需的存储空间。可以估算出程序 对计算机内存的使用程度 “复杂度”大多数情况下是指的时间复杂度 大O表示法：大O表示法是一种评估算法效率的“标尺”，以诸如$O(n)$、$ O(n^2)$的形式表示算法的效率，其中n为问题的数据大小。 常用的复杂度比较 $ n $ $ log(n) $ $ \sqrt n$ $ nlog(n) $ $ n^2 $ $ 2^n $ $ n! $ 5 2 2 10 25 32 120 10 3 3 30 100 1024 3628800 20 4 4 80 400 1048576 约$ 2.4 \times 10^{18}$ 50 5 7 250 2500 约$ 10^{15}$ 约$ 3 \times 10^{64}$ 100 6 10 600 10000 约$ 10^{30}$ 约$ 9.3\times 10^{157}$ 1000 9 31 9000 $ 10^6$ 约$ 10^{300}$ 约$ 4 \times 10^{2567}$ $10^4$ 13 100 $ 1.3\times 10^{5}$ $ 10^9$ 约$ 10^{3000}$ 约$ 10^{35660}$ $10^5$ 16 316 $ 1.6 \times 10^{6}$ $ 10^{10}$ 约$ 10^{30000}$ 约$ 10^{456574}$ $ 10^6$ 19 100 $ 1.9 \times 10^{7}$ $ 10^{12}$ 约$ 10^{300000}$ 约$ 10^{5565709}$ 稳定排序是指在出现多次相同数据时，能保证稳定输出的排序算法 初等排序 排序 最好 最坏 稳定情况 插入排序 N（有序） $O(N^2)$ 稳定 冒泡排序 $O(N)$ $O(N^2)$ 稳定 选择排序 $O(N^2)$ $O(N^2)$ 不稳定 希尔排序 $O(N)$ $O(N^2)$ 不稳定 插入排序 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 1234567891011121314151617void InsertSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) &#123; int j=i-1; if(a[i]&lt;a[i-1])&#123; //若第i个元素小于第i-1个元素,移动有序序列插入------大于的话则直接插入 int swap=a[i]; //存储将要排序的元素 a[i]=a[i-1]; //向后移动一个元素 while(swap&lt;a[j])//查询将要插入的位置 &#123; a[j+1]=a[j]; j--; //元素后移 &#125; a[j+1]=swap;//循环结束 插入到指定位置 &#125; &#125;&#125; 冒泡排序 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213#include&lt;stdio.h&gt;void BuddleSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; for( int j=0;j&lt;n-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; int swap=a[j]; a[j]=a[j+1]; a[j+1]=swap; &#125; &#125; &#125;&#125; 选择排序步骤： 未排序序列中找到最小元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 以此类推，直到所有元素均排序完毕。 1234567891011121314151617181920void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; int min=i; //存放数组最小值的位置 for(int j=i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[min])&#123; min=j; //找出最小值，并记录位置 &#125; &#125; if(min!=i) //最小元素与第i个元素互换位置 &#123; int swap=a[min]; a[min]=a[i]; a[i]=swap; &#125; &#125;&#125; 希尔排序步骤： 选取间隔为g的元素进行插入排序 缩小g的范围，新的g与原g互质 重复执行步骤1，2 最后选取g=1执行一次插入排序 1234567891011121314151617insertionSort(A,n,g)&#123; for i = g to n-1 v=A[i] j=i-g while j&gt;=0 &amp;&amp; A[j]&gt;v A[j+g]=a[j] j=j-g cnt++ A[j+g]=v&#125;shellSort(A,n)&#123; cnt=0; m=?; g[]=&#123;……,1&#125;; for i=0 to m-1 insertionSort(A,n,g[i])&#125; 注： 最后一定要执行一次g=1的普通 插入排序 ，确保正确 参考教材：《挑战程序设计竞赛2 算法数据结构》 参考资料：https://www.cnblogs.com/xaimicom/p/9189471.html]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>程序 算法</tag>
      </tags>
  </entry>
</search>
